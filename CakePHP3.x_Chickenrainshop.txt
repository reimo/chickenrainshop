//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CakePHP3.3.1 Kiến thức cơ bản và cách xây dựng chickenrainshop project
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Phần 1: Các thiết lập ban đầu

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
1. Phân tích yêu cầu: 
Chickenrainshop là dự án triển khai hệ thống bán sách online được xây dựng bằng CakePHP3.3
Nó bao gồm 3 phần chính: 
 + Home: Trang chủ, hiển thị danh sách các cuốn sách có trong kho (bổ sung chức 
năng tìm kiếm sách,...)
 + Thông tin sách: hiển thị nội dung cụ thể từng cuốn sách
 + Thông tin giỏ hàng: Hiển thị thông tin giỏ hàng của khách khi đặt mua sách 
Ngoài ra chức năng admin sẽ được sử dụng để quản lý sách.



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2. Xây dựng mô hình dữ liệu và csdl cho project 

CDM: Conceptual Data Model (Mô hình dữ liệu quan niệm hay mô hình quan niệm thực thể): 
là mô hình chi tiết mô tả toàn bộ cấu trúc dữ liệu tổ chức mà nó không phụ thuộc vào 
bất kỳ một hệ quản trị cơ sở dữ liệu nào hay sự xem xét việc cài đặt. Đây là một mô 
hình biểu diễn mức độ hợp lý, chi tiết về dữ liệu của một tổ chức hay một hệ thống.
CDM biểu diễn các thực thể chứa các thuộc tính và các thực thể này có quan hệ với nhau, 
có thể là 1-nhiều, nhiều-nhiều, hay là nhiều-1.

PDM: Physical Data Model (Mô hình dữ liệu vật lý) mô hình này thể hiện sự sắp xếp và cài 
đặt của dữ liệu trên một hệ quản trị cơ sở dữ liệu nào đó (trong video thì PDM thể hiện 
sự cài đặt của dữ liệu trên mySQL).
PDM biểu diễn các table (bảng) có mối quan hệ với nhau, mỗi bảng có nhiều trường dữ liệu 
trong đó.

Các quy tắc của CakePHP khi tạo CSDL:

- Tên bảng đặt theo dạng số nhiều của tiếng anh (thêm s, hoặc es)
VD: teams, books, matches...
Và không dùng các từ dễ bị nhầm lẫn với từ khóa của CakePHP(file, new...)
- Khóa chính (primary key) được quy định tên mặc định là id, thuộc kiểu int và là trường 
số tự tăng (auto_increment)
- Khóa ngoại (foreign key) được quy định là tên bảng ở dạng số ít và kèm với cụm _id.
VD: category_id, book_id...

- Các trường created và modified: thuộc kiểu dateime hoặc timestamp mặc định là null. 
Và 2 trường này dùng để lưu ngày tạo mẩu tin (created), và ngày bạn update mẩu tin đó 
(updated) một cách tự động, và chúng ta không cần phải thao tác gì trên đó cả.


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
3. Xây dựng Model - View - Controller từ csdl đã có

1.1. Cài đặt componer với Xampp
Bây giờ ta sẽ vào trang chủ của Composer-> Getting Started -> Locally -> Click vào link: the Dowload Page và nó sẽ đưa ta đến đường dẫn sau:
https://getcomposer.org/download/ 
Tại đây bạn sẽ thấy có 2 cách cài đặt và sử dụng file exe để cài trực tiếp hoặc dùng commandline để cài bằng dòng lệnh. Tôi sử dụng commandline
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
php composer-setup.php
php -r "unlink('composer-setup.php');"
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Bây giờ ta chỉ việc bật chế độ Shell của Xampp, di chuyển tới thư mục htdocs 
(chương trình Shell mặc định root tại thư mục cài đặt xampp nên ta cần di chuyển tới thư mục htdocs ở bên trong nó )
>cd htdocs
Parse đoạn mã trên vào, nó sẽ thực thi từng dòng lệnh 1 như sau

> php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
> php -r "if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
> php composer-setup.php
> php -r "unlink('composer-setup.php');"

Và đây là kết quả thực thi
 
Bây giờ bên trong thư mục htdocs sẽ xuất hiện 1 file đó là Conposer.phar , đây chính là file thực thi của conposer
 
1.2. Tạo project chickenrainshop
Tiếp theo ta sẽ sử dụng composer để tạo 1 project tên là bookmarker. Vẫn tiếp tục bằng chương trình Shell Command của Xampp, ta thực thi lệnh sau:

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
php composer.phar create-project --prefer-dist cakephp/app chickenrainshop
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Sau khi đợi nó tự động install các package cần thiết thì nó sẽ hỏi bạn có muốn thiết lập quyền sở hữu (folder permissions) cho folder “app/config” hay không? Bạn hãy chọn y
Như vậy bây giờ trong thư mục htdocs đã tự động sinh ra 1 project có tên là “chickenrainshop” 

Ta import csdl đã được xây dựng vào database có tên: chickenrainshop

Bởi vì database được thiết kế theo những quy ước của CakePHP, 
cho nên ta có thể sử dụng chương trình “bake console” để sinh ra một cách nhanh chóng 
một chương trình đơn giản. Ta thực thi các lệnh sau:

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# cd htdocs/bookmarker
# bin\cake bake all books
# bin\cake bake all categories
# bin\cake bake all comments
# bin\cake bake all coupons
# bin\cake bake all groups
# bin\cake bake all orders
# bin\cake bake all users
# bin\cake bake all writers
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Sau khi thực thi tất cả các lệnh trên thì nó đã tự động sinh code ra cho chúng ta.
Ngoài ra trong phần này mình cũng nhắc qua về 1 số quy ước khi viết front-end và back-end
Ở đây mình định nghĩa 
front-end là phần xử lý view của người dùng, là phần hệ thống tương tác trực tiếp với người 
dùng như là hiển thị danh sách sách , search sách , hiển thị thông tin sách , hiển thị giỏ hàng, 
thao tác giỏ hàng và các xử lý tương tác
back-end là phần của admin dùng để xử lý việc thêm , sửa, xóa ,...đối với sách cũng như người dùng.
Như vậy để dễ dàng hơn khi làm việc, ta sẽ tuân thủ 1 số quy định sau đây: 
+ URL:
front-end: /controller/action -> URL: /books/index
back-end:  /admin/controller/action -> URL: admin/books/admin_index
+ Action - View
front-end: function index(){} -> view tương ứng: index.ctp
back-end:  function admin_index() {} => view tương ứng: admin_index.ctp
+ Layout
Trong cake thì khi sử dụng layout nó được mặc định sử dụng 1 layout là default.ctp
Như vậy ta cũng sẽ phân chia layout mặc định của front-end và back-end như sau:
front-end layout: Layout/default.ctp
back-end layout:  Layout/admin.ctp

Bây giờ ta sẽ tìm hiểu qua về file default.ctp và cấu trúc của nó.
File này là file layout mặc định được cake sử dụng khi load trang , nó là nơi định nghĩa các 
file css , js được sử dụng trong chương trình (Khi phát triển thì có thể tùy mục đích mà ta định nghĩa
lại cũng được)

Trong cakePHP2.x thì nó được viết 
<?php
    echo $this->Html->meta('icon');

    echo $this->Html->css('cake.generic');
    echo $this->Html->css('mystyle');
    
    echo $this->Html->script('jquery-3.1.0.min');

    echo $this->fetch('meta');
    echo $this->fetch('css');
    echo $this->fetch('script');
?>

Ở đây nó sử dụng Helper Html do cake xây dựng sẵn để load file css,js theo tên của chúng.
Các file này sẽ được đặt trong thư mục webroot/css và webroot/js

Tuy nhiên chuyển sang CakePHP3.x thì nó có cách viết khá lạ
<?= $this->Html->css('mystyle') ?>
Vậy cách này thì có gì khác cách trên ? Thực ra là không khác gì nhau cả, cách viết này
là một dạng short_open_tag (bạn có thể đọc về echo trong php để tìm hiểu về cách viết này)

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Phần 2: Quản lý nội dung
4. Các phương pháp truy vấn dữ liệu trong CakePHP

Trong CakePHP , thông thường sử dụng 2 hàm là find() và query() để truy vấn dữ liệu
Ta sẽ đi nói về từng hàm, chức năng và cách dùng của nó
1 - find($type , $option)
Đối với $type - kiểu truy vấn:
+all : tìm và lấy hết các mẫu tin trong csdl
+fist: tìm và trả về mẫu tin đầu tiên tìm thấy trong csdl
+list: tương tự như all nhưng chỉ trả về id
+count:tìm những dữ liệu đc yêu cầu và trả về số mẫu tin mà nó tìm được
+neighbors: Trả về mẫu tin đứng trước và sau mẫu tin mà chúng ta yêu cầu nó tìm
+threaded: Giống như là all, nhưng chỉ sử dụng cho dữ liệu có cấu trúc cây. 
chẳng hạn như khi ta sử dụng TreeBehavior vào tìm categories thì ta cần dùng sử 
dụng kiểu truy vấn này để làm cây danh mục.

Đối với option - các tùy chọn khi truy vấn và được đặt trong 1 mảng (với tùy chọn là key , 
và điều kiện ràng buộc cho tùy chọn là value) , có 1 số tùy chọn mà ta hay sử dụng khi truy vấn: 

+fields: Tùy chọn này sẽ giúp chúng ta lấy các trường dữ liệu mà chúng ta muốn trong csdl
Nếu chỉ muốn lấy 1 trường thì ta đặt nó trong 1 cặp dấu nháy('') , nhưng nếu lấy nhiều trường
thì ta cần đặt nó trong mảng
+conditions: Điều kiện khi tìm kiếm csdl
Tương tự như câu lệnh where trong query, và các điều kiện cũng được đặt trong 1 mảng
+order: sắp xếp csdl theo 1 trường nào đó theo 1 thứ tự nào đó
+limit: Lấy ra số lượng mẫu tin chỉ định (chỉ định là interger)
+recursive: Tùy chọn này sẽ lấy dữ liệu theo mối quan hệ của bảng dữ liệu mà ta cần lấy
Và có 4 mức recursive cho chúng ta tùy chọn là : -1 , 0 , 1 và 2

VD: //Cakephp2.x
<?php
/*中断*/ 
$notes = $this->Note->find('all' , array(
    'fields' => array('id' , 'title' , 'content') ,
    'conditions' => array('title LIKE' => '%PHP%') ,
    'order' => array('id' => 'asc') , // array('id asc'); cũng được
    'limit' => 5
));

$notes = $this->Note->find('first');

?>

Trong cakephp2.x thì việc sử dụng find($type , $option) sẽ không có vấn đề gì xảy ra nhưng
từ cakephp3.x trở đi, nó đã được thay thế khá nhiều.

Ở cakephp2.x thì kết quả của find sẽ trả về mảng, tuy nhiên từ 3.x trở đi thì tất cả đều được
đưa về dưới dạng object. Vì thế việc sử dụng hàm pr($var) khá là khó debug trong cakephp3.x

Trong cakephp3.x document, hàm find() cũng được support nhưng đã có nhiều thay đổi trong cách sử dụng.
Do từ 3.x trở đi, cake không sử dụng trực tiếp 1 class Model mà thông qua 2 class Table và Modify nên
khi sử dụng ta cần tạo ra 1 instance của Table.
Vì thế trước khi sử dụng hàm find() này, ta cần load instance của Table bằng cách:
<?php 
$instance_tbl = TableRegistry::get('table_name');
$result = $instance_tbl->find('all' , $option)->type_name();
?>

Trong cakephp3.x thì những $type = 'first' , 'count' sẽ không còn sử dụng được nữa , mà thay vào đó
ta sẽ chỉ sử dụng $type = 'all' với $option , sau đó lấy kết quả thu được gọi tới first() , count()
VD:
<?php 
$noteInstance = TableRegistry::get('Notes');
$notes = $noteInstance->find('all');
$first = $notes->first(); // $note->find()->first(); cũng hoạt động tương tự
$count = $notes->count(); // $note->find()->count(); cũng hoạt động tương tự
?>

Về find list thì ta vẫn có thể sử dụng nó như 1 $type đặt trong find() được
$bookInstance->find('list' , $option);
Tuy nhiên list này sẽ ko phải trả về id mà sẽ trả về danh sách của $this->displayField('');
đã được định nghĩa trong Table. Nếu trong class Table không ghi gì thì nó sẽ mặc định là id.

Trong cakephp3.x thì recursive đã được loại bỏ mà thay vào đó chúng ta sẽ sử dụng contain để quản lý việc đó.

Đối với find('neghbors') thì trong CakePHP3.x đã không còn hỗ trợ nó nữa, nên nếu muốn sử dụng bạn có thể
biến tấu nó theo cách sau:
src/Models/Table/ExampleTable.php
<?php 
/**
 * Find an item from a table by slug, along with it's two adjacent items
 *
 * @param string $slug
 * @return array
 */
public function neighbours(Query $query , $slug) {
    $current = $this->find()
        ->where(['slug' => $slug])
        ->first();

    $previous = $this->find()
        ->where(['publish_date <' => $current->publish_date->format('Y-m-d')])
        ->order(['publish_date' => 'DESC'])
        ->first();

    $next = $this->find()
        ->where(['publish_date >' => $current->publish_date->format('Y-m-d')])
        ->order(['publish_date' => 'DESC'])
        ->first();

    return [
        'current' => $current,
        'previous' => $previous,
        'next' => $next
    ];
}
?>

src/Controller/ExamplesController.php
<?php 
public function view($id = null) {
    $neighbors = $this->Examples->find('neighbors', $id );
}
?>

Ngoài ra thì ta có thể sử dụng thêm 1 số cách truy vấn khác cũng với find() như sau:
$instance->find()
    ->where(条件A)
    ->where(条件B)
    ->order(ソート条件A)
    ->order(ソート条件B)
    ->select(取得フィールド)
    ->all();
Cụ thể hơn ta có thể tham khảo tại: 
Cake3.x find():
+ http://qiita.com/kozo/items/87dc9f725e71dd742468 
+ http://qiita.com/zayarwinttun/items/7afae4cc9f5388babc38
Cake2.x find(): http://qiita.com/Tomooki_Tatsuguchi/items/7ea21324dd90d9cf92d7

Trong bài viết này, tác giả đã ghi rõ những thay đổi trong việc khai báo find() cũng như 
sử dụng các type , option của nó trong cakephp2.x và 3.x
http://norm-nois.com/blog/archives/3319 


2- query() 
Đối với query() thì sẽ rất thuận tiện cho những ai chưa thực sự quen thuộc với hàm find()
Vì chỉ cần viết câu lệnh SQL và truyền vào query như 1 tham số thì nó sẽ thực thi tìm kiếm
như những gì câu lệnh sql yêu cầu.
$sql = "select * from books";
$result = $this->Model->query($sql);

Tuy nhiên trong CakePHP3.x thì cách này đã không còn được sử dụng trực tiếp thông qua Model
mà thay vào đó ta phải dùng như sau:

use Cake\Datasource\ConnectionManager;
<?php 
$sql = 'SELECT * FROM articles';
$connection = ConnectionManager::get('my_connection')->execute($sql);
// Get one row
$results = $connection->fetch('assoc');
// Get all row
$results = $connection->fetchAll('assoc');
?>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
5. Quan hệ giữa các Model trong CakePHP
Các mối quan hệ trong CakePHP
Quan hệ 1-1: 1 thể hiện của A chỉ có thể có 1 thể hiện của B và ngược lại, 1 thể hiện của B
chỉ thuộc 1 thể hiện của A.
              A           <---(      chỉ có 1        )---->      B
           (hasOne)                                           (hasOne)
Quan hệ 1-n: 1 thể hiện của A có thể có 1 hoặc nhiều thể hiện của B , 1 thể hiện của B chỉ
thuộc về 1 thể hiện của A
              A           ----(có thể có 1 hoặc nhiều)---->      B
           (hasMany)      <---(     chỉ thuộc về     )----   (belongTo)
Quan hệ n-n: 1 thể hiện của A có thể có 1 hoặc nhiều thể hiện của A và ngược lại.
              A           <---(  có 1 hoặc nhiều     )---->      B
           (belongsToMany)                                   (belongsToMany)

Ta có thể xem về việc định nghĩa các mối quan hệ này trong các Table Object:
Trong BooksTable ta thấy định nghĩa:
<?php
    // 1 Book thì chỉ thuộc về 1 Categories
    $this->belongsTo('Categories', [
        'foreignKey' => 'category_id'
    ]);
    // 1 book thì có thể có 1 hoặc nhiều Comments
    $this->hasMany('Comments', [
        'foreignKey' => 'book_id'
    ]);
    // Một Book có thể có 1 hoặc nhiều người viết và 1 người có thể viết 1 hoặc nhiều sách
    // Ta cũng sẽ thấy 1 định nghĩa tương tự trong WritersTable Object
    $this->belongsToMany('Writers', [
        'foreignKey' => 'book_id',
        'targetForeignKey' => 'writer_id',
        'joinTable' => 'books_writers'
    ]);
?>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
6. Sử dụng Containable Behavior
Bài này tạm thời bỏ qua , vì trong cakephp2.x thì nó được support nhưng trong các phiên bản cakephp3.x thì nó đã được xóa bỏ.

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
7. Tạo lại chức năng hiển thị book mới
+ Chỉnh sửa router để trang chủ là trang hiển thị books
Đầu tiên ta vào /config/routes.php và thêm vào: 
// Với định nghĩa này thì nó sẽ mặc định root sẽ đi vào controller books tại action index.
Router::connect('/' , array('controller' => 'books' , 'action' => 'index'));

+ Viết lại Controller

+ Viết lại Template/Books/index.ctp

Theo hướng dẫn thì 'contain' => ['Writers' , ['fields']]

Vấn đề: Khi sử dụng 'contain' thì viết truy vấn 
'contain' => ['Writers' => ['fields' => 'name']]
sẽ không thể thực thi mà ta cần sử dụng callback như sau:
->contain([
        'Writers' => function($q) {
            return $q->select(['name']);
        }
])

<?php 
/**
 * Index method
 * Hiển thị 10 quyển sách mới nhất trên trang chủ
 * @return \Cake\Network\Response|null
 */
public function index() {

    $bookInstance = TableRegistry::get('Books');
    $books = $bookInstance->find()
            ->select(['id' ,'title' , 'image' , 'sale_price' , 'slug'])
            ->where(['published' => 1])
            ->order(['created' => 'desc'])
            ->limit(5)
            ->contain([
                    'Writers' => function($q) {
                        return $q->select(['name']);
                    }
            ])
            ->all();

    $this->set(compact('books'));
    
}
?>

+ Tách xử lý với Model thành 1 method riêng

Ta có thể viết trực tiếp hàm find() trong Controller , tuy nhiên việc viết mã xử lý database trong controller sẽ làm cho mã nguồn trở lên không được sạch và khó quản lý (Mọi xử lý liên quan tới database thì nên đặt trong model ). Vì vậy ta sẽ tách nó thành 1 method riêng trong Model như sau: 

/src/Controller/BooksController.php 
<?php 
public function index() {
      
    $bookInstance = TableRegistry::get('Books');
    // Tạo 1 hàm latest() trong model thực thi việc lấy ra 5 cuốn sách mới nhất trong csdl
    $books = $bookInstance->latest();
    
    $this->set(compact('books'));
    
}
?>

/src/Model/Table/BooksTable.php
<?php 
/**
* latest method
* Lấy ra 5 trường mới nhất trong bảng books
* @return \Cake\Datasource\ResultSetInterface
*/
public function latest() {
        return $this->find()
            ->select(['id' ,'title' , 'image' , 'sale_price' , 'slug'])
            ->where(['published' => 1])
            ->order(['created' => 'desc'])
            ->limit(5)
            ->contain([
                    'Writers' => function($q) {
                        return $q->select(['name']);
                    }
            ])
            ->all();
}
?>
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
8. Phân trang dữ liệu trong CakePHP

Hiện tại ta chỉ show ra 5 books mới nhất trong database, vậy nếu muốn xem tất cả sách
nhưng không phải hiển thị thành 1 danh sách toàn bộ dữ liệu như hiện tại thì ta cần sử dụng phân
trang trong CakePHP. Cake đã hỗ trợ việc phân trang này

Tạo 1 link xem dữ liệu mới:
+ Bổ sung link vào Template/Books/index.ctp
<h4><?php echo $this->Html->link('Xem thêm' , '/sachmoi/') ?></h4>
vào ngay phía dưới tiêu đề của trang index.ctp

Như vậy ta đã tạo thêm 1 phần mới dùng để hiển thị sách dưới dạng phân trang.
Trước hết ta sẽ khai báo router cho nó như sau:
+ Bổ sung router
<?php 
Router::connect('/sachmoi' , array('controller' => 'Books' , 'action' => 'latest_books'));
?>

+ Thêm action trong BooksController
Do trong trang latest_books ta sẽ phân trang dữ liệu nên việc sử dụng lại hàm latest() trong BooksTable là không phù hợp (vì hàm này chỉ thực thi việc lấy ra toàn bộ dữ liệu theo yêu cầu được thực thi bởi hàm find() chứ không thực thi việc phân trang) . Và ta cũng không thể sử dụng find() để thực thi việc phân trang được. 

Thì ở đây, cake đã hỗ trợ chúng ta sử dụng thành phần helper Paginator (trong các phiên bản 2.x thì khi muốn sử dụng helper này ta cần khai báo nó thông qua mã lệnh: 
<?php 
public $helper = array('Paginator');
?>
nhưng từ các phiên bản 3.x trở đi thì nó đã được khai báo như 1 thành phần mặc định của class Controller nên ta chỉ việc sử dụng mà không cần phải khai báo gì cả. )

Trong cakephp nó hỗ trợ 1 phương thức thực thi việc phân trang dữ liệu đó là paginate(). Phương thức này được khai báo trong PaginatorComponent. Ngoài ra thì điều kiện phân trang sẽ được sử dụng thông qua 1 biến điều khiển mặc định có tên là $paginate , cho nên mọi mong muốn phân trang sẽ được khai báo và cake sẽ xử lý thông qua nó. Nếu không có khai báo gì thì $paginate sẽ nhận giá trị mặc định được khai báo trong PaginatorComponent.


Ở đây ta sẽ sử dụng hàm paginate() như sau: 
<?php
public $paginate = array(
        'order' => array('created' => 'desc') ,
        'limit' => 5
);

/* Ta bắt buộc phải viết tên hàm thành latestBooks chứ không phải là latest_books() như trong cake2.x */
public function latestBooks() {
    /* Nếu ta khai báo $paginate bên trong action thì mọi khai báo của $paginate trước đó sẽ được vô hiệu hóa và sử dụng khai báo này. Còn nếu không thì nó sẽ sử dụng $paginate được khai báo bên ngoài , cuối cùng mới sử dụng các thiết lập mặc định. */
    /* $paginate có độ ưu tiên cao nhất */
    $this->paginate = array(
            'fields' => ['id' , 'title' , 'slug' , 'sale_price' , 'image'] ,
            'order' => ['created' => 'desc'] ,
            'limit' => 5 , 
            'contain' => ['Writers' => function($q) {
                        return $q->select(['name' , 'slug']);
                    } ] ,
            'conditions' => ['published' => 1]
    );
    
    /* Ngoài việc đưa ra các dữ liệu được truy vấn thì nó còn đưa thêm các thông tin thực thi việc phân trang.  */
    $books = $this->paginate();
    $this->set(compact('books'));
}
?>


+ Thêm view mới Template/Books/latest_books.ctp (tên view phải tương ứng tên action)

<h2><?php echo __('Sách mới'); ?></h2>
<p>
<!-- PaginatorHelper sẽ nhận định sort theo title , created -->
<?php echo $this->Paginator->sort('title' , 'Sắp xếp theo tên sách'); ?> |
<?php echo $this->Paginator->sort('created' , 'Sắp xếp mới nhất/cũ nhất'); ?>
</p>
<div class="books index large-9 medium-8 columns content">
    <?php 
    foreach ($books as $book) {
        echo $book->title . "<br><br>";
        /* Sử dụng HtmlHelper thay thế cho tag <img> */
        echo $this->Html->image($book->image , array(
                'width' => '120px' ,
                'height' => '160px'
        )) . "<br><br>";
        /* Chuyển đổi tiền tệ */
        echo "Giá bán: " . $this->Number->format($book->sale_price , array(
                'places' => 0 ,
                'after' => 'VND'
        )) . "<br>";
        echo "Tác giả: ";
        foreach ($book->writers as $writer) { 
            echo $writer->name . "   ";
        }
        echo "<hr>";
    }
    ?>
    <p>
    <!-- Trong cake hỗ trợ gọi tới 1 số thuộc tính được xây dựng sẵn như 
    {{page}} để hiển thị trang hiện tại trong tổng số trang
    {{pages}} để hiện thị tổng số trang phân trang
    {{current}}: hiển thị số trang hiện tại
    -->
    <?php echo $this->Paginator->counter("Trang {{page}}/{{pages}}, hiển thị {{current}} quyển sách trong tổng số {{count}} quyển."); ?>
    </p>
    <ul class="pagination">
        <?= $this->Paginator->prev('<i class="fa fa-fw fa-chevron-left">Quay lại</i>', ['escape' => false]) ?>
        <?= $this->Paginator->numbers() ?>
        <?= $this->Paginator->next('<i class="fa fa-fw fa-chevron-right">Kế tiếp</i>', ['escape' => false]) ?>
    </ul>
</div>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
9. Element trong CakePHP

Trong CakePHP có hỗ trợ sử dụng 1 thành phần gọi là Element. Vậy element này mục đích để làm gì ? Tại sao cần sử dụng element ? thì trong phần này ta sẽ đi nói rõ về nó.

Trong source code của 1 hệ thống sẽ luôn có những phần code view được lặp đi lặp lại nhiều lần, và việc viết mã giành cho những phần này khi thay đổi ta sẽ phải sửa tương tự cho từng view, như vậy sẽ rất bất tiện và có thể gây ra nhiều nhầm lẫn. Vì thế mà element được ra đời. Element là phần mã view được sử dụng lặp đi lặp lại nhiều lần, nên ta chỉ việc tạo 1 file trong thư mục Template/Element/ thì cake sẽ hiểu và load file đó mỗi khi element được gọi. Như thế khi chỉnh sửa hoặc thay đổi ta cũng chỉ cần thay đổi 1 file element mà không cần chỉnh sửa từng view, thật tiện lợi phải không :)

Ví dụ: Phần mã hiển thị việc phân trang sẽ không chỉ được viết ở trang chủ hiển thị sách, mà còn được viết ở rất nhiều trang khác như hiển thị danh sách tác giả, danh sách người dùng,...
Như vậy việc tách nó ra thành 1 đối tượng element là hợp lý.
Trong Template/Element/ ta tạo 1 file có tên: paginator.ctp (nó có đuôi ctp như những view khác sử dụng trong cake) với nội dung như sau: 

<?php echo $this->Paginator->counter("Trang {{page}}/{{pages}}, hiển thị {{current}} quyển sách trong tổng số {{count}} quyển."); ?>
</p>
    <ul class="pagination">
        <?= $this->Paginator->prev('<i class="fa fa-fw fa-chevron-left">Quay lại</i>', ['escape' => false]) ?>
        <?= $this->Paginator->numbers() ?>
        <?= $this->Paginator->next('<i class="fa fa-fw fa-chevron-right">Kế tiếp</i>', ['escape' => false]) ?>
</ul>

Như vậy trong trang /Template/Books/latest_books.ctp ta chỉ việc gọi đến đối tượng element này như sau:
<?php echo $this->element('paginator'); ?>

Tuy nhiên, nếu ta đặt nội dung paginator.ctp như trên thì trong phần hiển thị view của writers nó cũng sẽ hiển thị là 'cuốn sách/quyển' thay vì 'tác giả/tác giả'. Vậy làm thế nào để ta có thể điều khiển được điều này.

Trong file paginator.ctp , thay vì cố định các giá trị như 'cuốn sách/quyển' hay 'tác giả/tác giả' thì ta sẽ thay thế nó bằng 1 biến, giả sử là biến $object và sử dụng chức năng nối chuỗi trong php như sau: 

<?php echo $this->Paginator->counter("Trang {{page}}/{{pages}}, hiển thị {{current}} " . $object . " trong tổng số {{count}} ". $object ."."); ?>

Và khi gọi đến element paginator này ta sẽ gán thêm giá trị cho biến $object như sau:
/Template/Books/latest_books.ctp 
<?php echo $this->element('paginator' , array('object' => 'tác giả')); ?>
/Template/Writers/index.ctp
<?php echo $this->element('paginator' , array('object' => 'cuốn sách')); ?>

Ở đây ta gán biến object là 1 key trong danh sách các option của element, cake sẽ tự động hiểu và thay thế giá trị tương ứng cho nó.

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
10. Tạo link thân thiện trong CakePHP


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
11. Phân trang dữ liệu quan hệ

Sau khi đã tạo link thân thiện với các phần như 
+ books => sach-moi
+ categories => danh-muc
+ writers => tac-gia

Bây giờ ta hãy xem trong phần view của category thì mỗi category lại tồn tại rất nhiều sách có quan hệ với nó, nên bây giờ thay vì hiển thị 1 danh sách dài các books đó thì ta cũng sẽ thực hiện phân trang cho nó

vd: http://localhost/chickenrainshop/danh-muc/kinh-te -> Tất cả các sách thuộc danh mục "kinh tế" sẽ được liệt kê tại đây, nên bây giờ ta sẽ đi phân trang cho nó.
