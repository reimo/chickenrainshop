//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CakePHP3.3.1 Kiến thức cơ bản và cách xây dựng chickenrainshop project
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Phần 1: Các thiết lập ban đầu

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
1. Phân tích yêu cầu: 
Chickenrainshop là dự án triển khai hệ thống bán sách online được xây dựng bằng CakePHP3.3
Nó bao gồm 3 phần chính: 
 + Home: Trang chủ, hiển thị danh sách các cuốn sách có trong kho (bổ sung chức 
năng tìm kiếm sách,...)
 + Thông tin sách: hiển thị nội dung cụ thể từng cuốn sách
 + Thông tin giỏ hàng: Hiển thị thông tin giỏ hàng của khách khi đặt mua sách 
Ngoài ra chức năng admin sẽ được sử dụng để quản lý sách.



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2. Xây dựng mô hình dữ liệu và csdl cho project 

CDM: Conceptual Data Model (Mô hình dữ liệu quan niệm hay mô hình quan niệm thực thể): 
là mô hình chi tiết mô tả toàn bộ cấu trúc dữ liệu tổ chức mà nó không phụ thuộc vào 
bất kỳ một hệ quản trị cơ sở dữ liệu nào hay sự xem xét việc cài đặt. Đây là một mô 
hình biểu diễn mức độ hợp lý, chi tiết về dữ liệu của một tổ chức hay một hệ thống.
CDM biểu diễn các thực thể chứa các thuộc tính và các thực thể này có quan hệ với nhau, 
có thể là 1-nhiều, nhiều-nhiều, hay là nhiều-1.

PDM: Physical Data Model (Mô hình dữ liệu vật lý) mô hình này thể hiện sự sắp xếp và cài 
đặt của dữ liệu trên một hệ quản trị cơ sở dữ liệu nào đó (trong video thì PDM thể hiện 
sự cài đặt của dữ liệu trên mySQL).
PDM biểu diễn các table (bảng) có mối quan hệ với nhau, mỗi bảng có nhiều trường dữ liệu 
trong đó.

Các quy tắc của CakePHP khi tạo CSDL:

- Tên bảng đặt theo dạng số nhiều của tiếng anh (thêm s, hoặc es)
VD: teams, books, matches...
Và không dùng các từ dễ bị nhầm lẫn với từ khóa của CakePHP(file, new...)
- Khóa chính (primary key) được quy định tên mặc định là id, thuộc kiểu int và là trường 
số tự tăng (auto_increment)
- Khóa ngoại (foreign key) được quy định là tên bảng ở dạng số ít và kèm với cụm _id.
VD: category_id, book_id...

- Các trường created và modified: thuộc kiểu dateime hoặc timestamp mặc định là null. 
Và 2 trường này dùng để lưu ngày tạo mẩu tin (created), và ngày bạn update mẩu tin đó 
(updated) một cách tự động, và chúng ta không cần phải thao tác gì trên đó cả.


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
3. Xây dựng Model - View - Controller từ csdl đã có

1.1. Cài đặt componer với Xampp
Bây giờ ta sẽ vào trang chủ của Composer-> Getting Started -> Locally -> Click vào link: the Dowload Page và nó sẽ đưa ta đến đường dẫn sau:
https://getcomposer.org/download/ 
Tại đây bạn sẽ thấy có 2 cách cài đặt và sử dụng file exe để cài trực tiếp hoặc dùng commandline để cài bằng dòng lệnh. Tôi sử dụng commandline
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
php composer-setup.php
php -r "unlink('composer-setup.php');"
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Bây giờ ta chỉ việc bật chế độ Shell của Xampp, di chuyển tới thư mục htdocs 
(chương trình Shell mặc định root tại thư mục cài đặt xampp nên ta cần di chuyển tới thư mục htdocs ở bên trong nó )
>cd htdocs
Parse đoạn mã trên vào, nó sẽ thực thi từng dòng lệnh 1 như sau

> php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
> php -r "if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
> php composer-setup.php
> php -r "unlink('composer-setup.php');"

Và đây là kết quả thực thi
 
Bây giờ bên trong thư mục htdocs sẽ xuất hiện 1 file đó là Conposer.phar , đây chính là file thực thi của conposer
 
1.2. Tạo project chickenrainshop
Tiếp theo ta sẽ sử dụng composer để tạo 1 project tên là bookmarker. Vẫn tiếp tục bằng chương trình Shell Command của Xampp, ta thực thi lệnh sau:

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
php composer.phar create-project --prefer-dist cakephp/app chickenrainshop
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Sau khi đợi nó tự động install các package cần thiết thì nó sẽ hỏi bạn có muốn thiết lập quyền sở hữu (folder permissions) cho folder “app/config” hay không? Bạn hãy chọn y
Như vậy bây giờ trong thư mục htdocs đã tự động sinh ra 1 project có tên là “chickenrainshop” 

Ta import csdl đã được xây dựng vào database có tên: chickenrainshop

Bởi vì database được thiết kế theo những quy ước của CakePHP, 
cho nên ta có thể sử dụng chương trình “bake console” để sinh ra một cách nhanh chóng 
một chương trình đơn giản. Ta thực thi các lệnh sau:

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# cd htdocs/bookmarker
# bin\cake bake all books
# bin\cake bake all categories
# bin\cake bake all comments
# bin\cake bake all coupons
# bin\cake bake all groups
# bin\cake bake all orders
# bin\cake bake all users
# bin\cake bake all writers
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Sau khi thực thi tất cả các lệnh trên thì nó đã tự động sinh code ra cho chúng ta.
Ngoài ra trong phần này mình cũng nhắc qua về 1 số quy ước khi viết front-end và back-end
Ở đây mình định nghĩa 
front-end là phần xử lý view của người dùng, là phần hệ thống tương tác trực tiếp với người 
dùng như là hiển thị danh sách sách , search sách , hiển thị thông tin sách , hiển thị giỏ hàng, 
thao tác giỏ hàng và các xử lý tương tác
back-end là phần của admin dùng để xử lý việc thêm , sửa, xóa ,...đối với sách cũng như người dùng.
Như vậy để dễ dàng hơn khi làm việc, ta sẽ tuân thủ 1 số quy định sau đây: 
+ URL:
front-end: /controller/action -> URL: /books/index
back-end:  /admin/controller/action -> URL: admin/books/admin_index
+ Action - View
front-end: function index(){} -> view tương ứng: index.ctp
back-end:  function admin_index() {} => view tương ứng: admin_index.ctp
+ Layout
Trong cake thì khi sử dụng layout nó được mặc định sử dụng 1 layout là default.ctp
Như vậy ta cũng sẽ phân chia layout mặc định của front-end và back-end như sau:
front-end layout: Layout/default.ctp
back-end layout:  Layout/admin.ctp

Bây giờ ta sẽ tìm hiểu qua về file default.ctp và cấu trúc của nó.
File này là file layout mặc định được cake sử dụng khi load trang , nó là nơi định nghĩa các 
file css , js được sử dụng trong chương trình (Khi phát triển thì có thể tùy mục đích mà ta định nghĩa
lại cũng được)

Trong cakePHP2.x thì nó được viết 
<?php
    echo $this->Html->meta('icon');

    echo $this->Html->css('cake.generic');
    echo $this->Html->css('mystyle');
    
    echo $this->Html->script('jquery-3.1.0.min');

    echo $this->fetch('meta');
    echo $this->fetch('css');
    echo $this->fetch('script');
?>

Ở đây nó sử dụng Helper Html do cake xây dựng sẵn để load file css,js theo tên của chúng.
Các file này sẽ được đặt trong thư mục webroot/css và webroot/js

Tuy nhiên chuyển sang CakePHP3.x thì nó có cách viết khá lạ
<?= $this->Html->css('mystyle') ?>
Vậy cách này thì có gì khác cách trên ? Thực ra là không khác gì nhau cả, cách viết này
là một dạng short_open_tag (bạn có thể đọc về echo trong php để tìm hiểu về cách viết này)

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Phần 2: Quản lý nội dung
4. Các phương pháp truy vấn dữ liệu trong CakePHP

Trong CakePHP , thông thường sử dụng 2 hàm là find() và query() để truy vấn dữ liệu
Ta sẽ đi nói về từng hàm, chức năng và cách dùng của nó
1 - find($type , $option)
Đối với $type - kiểu truy vấn:
+all : tìm và lấy hết các mẫu tin trong csdl
+fist: tìm và trả về mẫu tin đầu tiên tìm thấy trong csdl
+list: tương tự như all nhưng chỉ trả về id
+count:tìm những dữ liệu đc yêu cầu và trả về số mẫu tin mà nó tìm được
+neighbors: Trả về mẫu tin đứng trước và sau mẫu tin mà chúng ta yêu cầu nó tìm
+threaded: Giống như là all, nhưng chỉ sử dụng cho dữ liệu có cấu trúc cây. 
chẳng hạn như khi ta sử dụng TreeBehavior vào tìm categories thì ta cần dùng sử 
dụng kiểu truy vấn này để làm cây danh mục.

Đối với option - các tùy chọn khi truy vấn và được đặt trong 1 mảng (với tùy chọn là key , 
và điều kiện ràng buộc cho tùy chọn là value) , có 1 số tùy chọn mà ta hay sử dụng khi truy vấn: 

+fields: Tùy chọn này sẽ giúp chúng ta lấy các trường dữ liệu mà chúng ta muốn trong csdl
Nếu chỉ muốn lấy 1 trường thì ta đặt nó trong 1 cặp dấu nháy('') , nhưng nếu lấy nhiều trường
thì ta cần đặt nó trong mảng
+conditions: Điều kiện khi tìm kiếm csdl
Tương tự như câu lệnh where trong query, và các điều kiện cũng được đặt trong 1 mảng
+order: sắp xếp csdl theo 1 trường nào đó theo 1 thứ tự nào đó
+limit: Lấy ra số lượng mẫu tin chỉ định (chỉ định là interger)
+recursive: Tùy chọn này sẽ lấy dữ liệu theo mối quan hệ của bảng dữ liệu mà ta cần lấy
Và có 4 mức recursive cho chúng ta tùy chọn là : -1 , 0 , 1 và 2

VD: //Cakephp2.x
<?php
/*中断*/ 
$notes = $this->Note->find('all' , array(
    'fields' => array('id' , 'title' , 'content') ,
    'conditions' => array('title LIKE' => '%PHP%') ,
    'order' => array('id' => 'asc') , // array('id asc'); cũng được
    'limit' => 5
));

$notes = $this->Note->find('first');

?>

Trong cakephp2.x thì việc sử dụng find($type , $option) sẽ không có vấn đề gì xảy ra nhưng từ cakephp3.x trở đi, nó đã được thay thế khá nhiều.

Ở cakephp2.x thì kết quả của find sẽ trả về mảng, tuy nhiên từ 3.x trở đi thì tất cả đều được đưa về dưới dạng object. 
Vì thế việc sử dụng hàm pr($var) khá là khó debug trong cakephp3.x

Trong cakephp3.x document, hàm find() cũng được support nhưng đã có nhiều thay đổi trong cách sử dụng.
Do từ 3.x trở đi, cake không sử dụng trực tiếp 1 class Model mà thông qua 2 class Table và Modify nên
khi sử dụng ta cần tạo ra 1 instance của Table.
Vì thế trước khi sử dụng hàm find() này, ta cần load instance của Table bằng cách:
<?php 
$instance_tbl = TableRegistry::get('table_name');
$result = $instance_tbl->find('all' , $option)->type_name();
?>

Trong cakephp3.x thì những $type = 'first' , 'count' sẽ không còn sử dụng được nữa , mà thay vào đó
ta sẽ chỉ sử dụng $type = 'all' với $option , sau đó lấy kết quả thu được gọi tới first() , count()
VD:
<?php 
$noteInstance = TableRegistry::get('Notes');
$notes = $noteInstance->find('all');
$first = $notes->first(); // $note->find()->first(); cũng hoạt động tương tự
$count = $notes->count(); // $note->find()->count(); cũng hoạt động tương tự
?>

Về find list thì ta vẫn có thể sử dụng nó như 1 $type đặt trong find() được
$bookInstance->find('list' , $option);
Tuy nhiên list này sẽ ko phải trả về id mà sẽ trả về danh sách của $this->displayField('');
đã được định nghĩa trong Table. Nếu trong class Table không ghi gì thì nó sẽ mặc định là id.

Trong cakephp3.x thì recursive đã được loại bỏ mà thay vào đó chúng ta sẽ sử dụng contain để quản lý việc đó.

Đối với find('neghbors') thì trong CakePHP3.x đã không còn hỗ trợ nó nữa, nên nếu muốn sử dụng bạn có thể
biến tấu nó theo cách sau:
src/Models/Table/ExampleTable.php
<?php 
/**
 * Find an item from a table by slug, along with it's two adjacent items
 *
 * @param string $slug
 * @return array
 */
public function neighbours(Query $query , $slug) {
    $current = $this->find()
        ->where(['slug' => $slug])
        ->first();

    $previous = $this->find()
        ->where(['publish_date <' => $current->publish_date->format('Y-m-d')])
        ->order(['publish_date' => 'DESC'])
        ->first();

    $next = $this->find()
        ->where(['publish_date >' => $current->publish_date->format('Y-m-d')])
        ->order(['publish_date' => 'DESC'])
        ->first();

    return [
        'current' => $current,
        'previous' => $previous,
        'next' => $next
    ];
}
?>

src/Controller/ExamplesController.php
<?php 
public function view($id = null) {
    $neighbors = $this->Examples->find('neighbors', $id );
}
?>

Ngoài ra thì ta có thể sử dụng thêm 1 số cách truy vấn khác cũng với find() như sau:
$instance->find()
    ->where(条件A)
    ->where(条件B)
    ->order(ソート条件A)
    ->order(ソート条件B)
    ->select(取得フィールド)
    ->all();
Cụ thể hơn ta có thể tham khảo tại: 
Cake3.x find():
+ http://qiita.com/kozo/items/87dc9f725e71dd742468 
+ http://qiita.com/zayarwinttun/items/7afae4cc9f5388babc38
Cake2.x find(): http://qiita.com/Tomooki_Tatsuguchi/items/7ea21324dd90d9cf92d7

Trong bài viết này, tác giả đã ghi rõ những thay đổi trong việc khai báo find() cũng như 
sử dụng các type , option của nó trong cakephp2.x và 3.x
http://norm-nois.com/blog/archives/3319 


2- query() 
Đối với query() thì sẽ rất thuận tiện cho những ai chưa thực sự quen thuộc với hàm find()
Vì chỉ cần viết câu lệnh SQL và truyền vào query như 1 tham số thì nó sẽ thực thi tìm kiếm
như những gì câu lệnh sql yêu cầu.
$sql = "select * from books";
$result = $this->Model->query($sql);

Tuy nhiên trong CakePHP3.x thì cách này đã không còn được sử dụng trực tiếp thông qua Model
mà thay vào đó ta phải dùng như sau:

use Cake\Datasource\ConnectionManager;
<?php 
$sql = 'SELECT * FROM articles';
$connection = ConnectionManager::get('my_connection')->execute($sql);
// Get one row
$results = $connection->fetch('assoc');
// Get all row
$results = $connection->fetchAll('assoc');
?>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
5. Quan hệ giữa các Model trong CakePHP
Các mối quan hệ trong CakePHP
Quan hệ 1-1: 1 thể hiện của A chỉ có thể có 1 thể hiện của B và ngược lại, 1 thể hiện của B
chỉ thuộc 1 thể hiện của A.
              A           <---(      chỉ có 1        )---->      B
           (hasOne)                                           (hasOne)
Quan hệ 1-n: 1 thể hiện của A có thể có 1 hoặc nhiều thể hiện của B , 1 thể hiện của B chỉ
thuộc về 1 thể hiện của A
              A           ----(có thể có 1 hoặc nhiều)---->      B
           (hasMany)      <---(     chỉ thuộc về     )----   (belongTo)
Quan hệ n-n: 1 thể hiện của A có thể có 1 hoặc nhiều thể hiện của A và ngược lại.
              A           <---(  có 1 hoặc nhiều     )---->      B
           (belongsToMany)                                   (belongsToMany)

Ta có thể xem về việc định nghĩa các mối quan hệ này trong các Table Object:
Trong BooksTable ta thấy định nghĩa:
<?php
    // 1 Book thì chỉ thuộc về 1 Categories
    $this->belongsTo('Categories', [
        'foreignKey' => 'category_id'
    ]);
    // 1 book thì có thể có 1 hoặc nhiều Comments
    $this->hasMany('Comments', [
        'foreignKey' => 'book_id'
    ]);
    // Một Book có thể có 1 hoặc nhiều người viết và 1 người có thể viết 1 hoặc nhiều sách
    // Ta cũng sẽ thấy 1 định nghĩa tương tự trong WritersTable Object
    $this->belongsToMany('Writers', [
        'foreignKey' => 'book_id',
        'targetForeignKey' => 'writer_id',
        'joinTable' => 'books_writers'
    ]);
?>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
6. Sử dụng Containable Behavior
Bài này tạm thời bỏ qua
(vì trong cakephp2.x thì nó được support nhưng trong các phiên bản cakephp3.x thì nó đã được bỏ đi mà sử dụng.)

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
7. Tạo lại chức năng hiển thị book mới
+ Chỉnh sửa router để trang chủ là trang hiển thị books
Đầu tiên ta vào /config/routes.php và thêm vào: 
// Với định nghĩa này thì nó sẽ mặc định root sẽ đi vào controller books tại action index.
Router::connect('/' , array('controller' => 'books' , 'action' => 'index'));

+ Viết lại Controller

+ Viết lại Template/Books/index.ctp

Theo hướng dẫn thì 'contain' => ['Writers' , ['fields']]

Vấn đề: Khi sử dụng 'contain' thì viết truy vấn 
'contain' => ['Writers' => ['fields' => 'name']]
sẽ không thể thực thi mà ta cần sử dụng callback như sau:
->contain([
        'Writers' => function($q) {
            return $q->select(['name']);
        }
])

<?php 
/**
 * Index method
 * Hiển thị 10 quyển sách mới nhất trên trang chủ
 * @return \Cake\Network\Response|null
 */
public function index() {

    $bookInstance = TableRegistry::get('Books');
    $books = $bookInstance->find()
            ->select(['id' ,'title' , 'image' , 'sale_price' , 'slug'])
            ->where(['published' => 1])
            ->order(['created' => 'desc'])
            ->limit(5)
            ->contain([
                    'Writers' => function($q) {
                        return $q->select(['name']);
                    }
            ])
            ->all();

    $this->set(compact('books'));
    
}
?>

+ Tách xử lý với Model thành 1 method riêng

Ta có thể viết trực tiếp hàm find() trong Controller , tuy nhiên việc viết mã xử lý database trong controller sẽ làm cho mã nguồn trở lên không được sạch và khó quản lý (Mọi xử lý liên quan tới database thì nên đặt trong model ). Vì vậy ta sẽ tách nó thành 1 method riêng trong Model như sau: 

/src/Controller/BooksController.php 
<?php 
public function index() {
      
    $bookInstance = TableRegistry::get('Books');
    // Tạo 1 hàm latest() trong model thực thi việc lấy ra 5 cuốn sách mới nhất trong csdl
    $books = $bookInstance->latest();
    
    $this->set(compact('books'));
    
}
?>

/src/Model/Table/BooksTable.php
<?php 
/**
* latest method
* Lấy ra 5 trường mới nhất trong bảng books
* @return \Cake\Datasource\ResultSetInterface
*/
public function latest() {
        return $this->find()
            ->select(['id' ,'title' , 'image' , 'sale_price' , 'slug'])
            ->where(['published' => 1])
            ->order(['created' => 'desc'])
            ->limit(5)
            ->contain([
                    'Writers' => function($q) {
                        return $q->select(['name']);
                    }
            ])
            ->all();
}
?>
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
8. Phân trang dữ liệu trong CakePHP

Hiện tại ta chỉ show ra 5 books mới nhất trong database, vậy nếu muốn xem tất cả sách
nhưng không phải hiển thị thành 1 danh sách toàn bộ dữ liệu như hiện tại thì ta cần sử dụng phân
trang trong CakePHP. Cake đã hỗ trợ việc phân trang này

Tạo 1 link xem dữ liệu mới:
+ Bổ sung link vào Template/Books/index.ctp
<h4><?php echo $this->Html->link('Xem thêm' , '/sachmoi/') ?></h4>
vào ngay phía dưới tiêu đề của trang index.ctp

Như vậy ta đã tạo thêm 1 phần mới dùng để hiển thị sách dưới dạng phân trang.
Trước hết ta sẽ khai báo router cho nó như sau:
+ Bổ sung router
<?php 
Router::connect('/sachmoi' , array('controller' => 'Books' , 'action' => 'latest_books'));
?>

+ Thêm action trong BooksController
Do trong trang latest_books ta sẽ phân trang dữ liệu nên việc sử dụng lại hàm latest() trong BooksTable là không phù hợp (vì hàm này chỉ thực thi việc lấy ra toàn bộ dữ liệu theo yêu cầu được thực thi bởi hàm find() chứ không thực thi việc phân trang) . Và ta cũng không thể sử dụng find() để thực thi việc phân trang được. 

Thì ở đây, cake đã hỗ trợ chúng ta sử dụng thành phần helper Paginator (trong các phiên bản 2.x thì khi muốn sử dụng helper này ta cần khai báo nó thông qua mã lệnh: 
<?php 
public $helper = array('Paginator');
?>
nhưng từ các phiên bản 3.x trở đi thì nó đã được khai báo như 1 thành phần mặc định của class Controller nên ta chỉ việc sử dụng mà không cần phải khai báo gì cả. )

Trong cakephp nó hỗ trợ 1 phương thức thực thi việc phân trang dữ liệu đó là paginate(). Phương thức này được khai báo trong PaginatorComponent. Ngoài ra thì điều kiện phân trang sẽ được sử dụng thông qua 1 biến điều khiển mặc định có tên là $paginate , cho nên mọi mong muốn phân trang sẽ được khai báo và cake sẽ xử lý thông qua nó. Nếu không có khai báo gì thì $paginate sẽ nhận giá trị mặc định được khai báo trong PaginatorComponent.


Ở đây ta sẽ sử dụng hàm paginate() như sau: 
<?php
public $paginate = array(
        'order' => array('created' => 'desc') ,
        'limit' => 5
);

/* Ta bắt buộc phải viết tên hàm thành latestBooks chứ không phải là latest_books() như trong cake2.x */
public function latestBooks() {
    /* Nếu ta khai báo $paginate bên trong action thì mọi khai báo của $paginate trước đó sẽ được vô hiệu hóa và sử dụng khai báo này. Còn nếu không thì nó sẽ sử dụng $paginate được khai báo bên ngoài , cuối cùng mới sử dụng các thiết lập mặc định. */
    /* $paginate có độ ưu tiên cao nhất */
    $this->paginate = array(
            'fields' => ['id' , 'title' , 'slug' , 'sale_price' , 'image'] ,
            'order' => ['created' => 'desc'] ,
            'limit' => 5 , 
            'contain' => ['Writers' => function($q) {
                        return $q->select(['name' , 'slug']);
                    } ] ,
            'conditions' => ['published' => 1]
    );
    
    /* Ngoài việc đưa ra các dữ liệu được truy vấn thì nó còn đưa thêm các thông tin thực thi việc phân trang.  */
    $books = $this->paginate();
    $this->set(compact('books'));
}
?>


+ Thêm view mới Template/Books/latest_books.ctp (tên view phải tương ứng tên action)

<h2><?php echo __('Sách mới'); ?></h2>
<p>
<!-- PaginatorHelper sẽ nhận định sort theo title , created -->
<?php echo $this->Paginator->sort('title' , 'Sắp xếp theo tên sách'); ?> |
<?php echo $this->Paginator->sort('created' , 'Sắp xếp mới nhất/cũ nhất'); ?>
</p>
<div class="books index large-9 medium-8 columns content">
    <?php 
    foreach ($books as $book) {
        echo $book->title . "<br><br>";
        /* Sử dụng HtmlHelper thay thế cho tag <img> */
        echo $this->Html->image($book->image , array(
                'width' => '120px' ,
                'height' => '160px'
        )) . "<br><br>";
        /* Chuyển đổi tiền tệ */
        echo "Giá bán: " . $this->Number->format($book->sale_price , array(
                'places' => 0 ,
                'after' => 'VND'
        )) . "<br>";
        echo "Tác giả: ";
        foreach ($book->writers as $writer) { 
            echo $writer->name . "   ";
        }
        echo "<hr>";
    }
    ?>
    <p>
    <!-- Trong cake hỗ trợ gọi tới 1 số thuộc tính được xây dựng sẵn như 
    {{page}} để hiển thị trang hiện tại trong tổng số trang
    {{pages}} để hiện thị tổng số trang phân trang
    {{current}}: hiển thị số trang hiện tại
    -->
    <?php echo $this->Paginator->counter("Trang {{page}}/{{pages}}, hiển thị {{current}} quyển sách trong tổng số {{count}} quyển."); ?>
    </p>
    <ul class="pagination">
        <?= $this->Paginator->prev('<i class="fa fa-fw fa-chevron-left">Quay lại</i>', ['escape' => false]) ?>
        <?= $this->Paginator->numbers() ?>
        <?= $this->Paginator->next('<i class="fa fa-fw fa-chevron-right">Kế tiếp</i>', ['escape' => false]) ?>
    </ul>
</div>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
9. Element trong CakePHP

Trong CakePHP có hỗ trợ sử dụng 1 thành phần gọi là Element. Vậy element này mục đích để làm gì ? Tại sao cần sử dụng element ? thì trong phần này ta sẽ đi nói rõ về nó.

Trong source code của 1 hệ thống sẽ luôn có những phần code view được lặp đi lặp lại nhiều lần, và việc viết mã giành cho những phần này khi thay đổi ta sẽ phải sửa tương tự cho từng view, như vậy sẽ rất bất tiện và có thể gây ra nhiều nhầm lẫn. Vì thế mà element được ra đời. Element là phần mã view được sử dụng lặp đi lặp lại nhiều lần, nên ta chỉ việc tạo 1 file trong thư mục Template/Element/ thì cake sẽ hiểu và load file đó mỗi khi element được gọi. Như thế khi chỉnh sửa hoặc thay đổi ta cũng chỉ cần thay đổi 1 file element mà không cần chỉnh sửa từng view, thật tiện lợi phải không :)

Ví dụ: Phần mã hiển thị việc phân trang sẽ không chỉ được viết ở trang chủ hiển thị sách, mà còn được viết ở rất nhiều trang khác như hiển thị danh sách tác giả, danh sách người dùng,...
Như vậy việc tách nó ra thành 1 đối tượng element là hợp lý.
Trong Template/Element/ ta tạo 1 file có tên: paginator.ctp (nó có đuôi ctp như những view khác sử dụng trong cake) với nội dung như sau: 

<?php echo $this->Paginator->counter("Trang {{page}}/{{pages}}, hiển thị {{current}} quyển sách trong tổng số {{count}} quyển."); ?>
</p>
    <ul class="pagination">
        <?= $this->Paginator->prev('<i class="fa fa-fw fa-chevron-left">Quay lại</i>', ['escape' => false]) ?>
        <?= $this->Paginator->numbers() ?>
        <?= $this->Paginator->next('<i class="fa fa-fw fa-chevron-right">Kế tiếp</i>', ['escape' => false]) ?>
</ul>

Như vậy trong trang /Template/Books/latest_books.ctp ta chỉ việc gọi đến đối tượng element này như sau:
<?php echo $this->element('paginator'); ?>

Tuy nhiên, nếu ta đặt nội dung paginator.ctp như trên thì trong phần hiển thị view của writers nó cũng sẽ hiển thị là 'cuốn sách/quyển' thay vì 'tác giả/tác giả'. Vậy làm thế nào để ta có thể điều khiển được điều này.

Trong file paginator.ctp , thay vì cố định các giá trị như 'cuốn sách/quyển' hay 'tác giả/tác giả' thì ta sẽ thay thế nó bằng 1 biến, giả sử là biến $object và sử dụng chức năng nối chuỗi trong php như sau: 

<?php echo $this->Paginator->counter("Trang {{page}}/{{pages}}, hiển thị {{current}} " . $object . " trong tổng số {{count}} ". $object ."."); ?>

Và khi gọi đến element paginator này ta sẽ gán thêm giá trị cho biến $object như sau:
/Template/Books/latest_books.ctp 
<?php echo $this->element('paginator' , array('object' => 'tác giả')); ?>
/Template/Writers/index.ctp
<?php echo $this->element('paginator' , array('object' => 'cuốn sách')); ?>

Ở đây ta gán biến object là 1 key trong danh sách các option của element, cake sẽ tự động hiểu và thay thế giá trị tương ứng cho nó.

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
10. Tạo link thân thiện trong CakePHP

Ở đây thì application tự động sinh ra các link url theo mô hình
localhost/project_name/controller_name/action_name/param1/param2/...
http://localhost/chickenrainshop/books/view/1

Tuy nhiên như thế thì nó sẽ không được đánh giá là 1 link thân thiện vị người dùng sẽ khó mà hiểu rõ mình đang thao tác đến đâu, cho đối tương nào
nếu chỉ nhìn vào url. Vì vậy trong phần này ta sẽ tạo link thân thiện cho chickenrainshop
Mô hình của link thân thiện đó là thay vì sử dụng param1 là id thì ta sẽ thay thế cụm /view/id thành /slug tương ứng
(slug là 1 trường được tạo ra để tạo link thân thiện cho ứng dụng, là tên tiêu đề, tên sách, tên tác giả,... được viết thường, không dấu và có phân cách từ
bằng ký tự '-' )
vd: 
http://localhost/chickenrainshop/sach-moi/toi-la-so-4 # Đây là link thân thiện của phần view thông tin books (sách) 
http://localhost/chickenrainshop/tac-gia/h-j-alex # Đây là link thân thiện của phần view thông tin writers (tác giả)
http://localhost/chickenrainshop/danh-muc/kinh-te # Đây là link thân thiện của phần view thông tin categories (thư mục)

Việc tạo link thân thiện này khá đơn giản , trước hết trong view ta thay việc truyền vào id thành slug tương ứng 
Ví dụ ta sẽ đi chỉnh sửa link thân thiện cho categories
Từ trang index ta sẽ đi đến trang view thông qua action View được khai báo trong /Template/Categories/index.ctp
<?= $this->Html->link(__('View'), ['action' => 'view', $category->id]) ?>
Ta sẽ thay thế thành:
<?= $this->Html->link(__('View'), ['action' => 'view', $category->slug]) ?>

Sau đó ta sẽ xử lý việc truyền slug vào thay cho id trong CategoriesController
<?php 
public function view($slug = null) {
    
    // B1: Lấy thông tin category tương ứng với tham số slug nhận được từ url    
    $options = array(
            'conditions' => array('Categories.slug' => $slug) ,
            'contain' => array('Books')
    );

    $category = $this->Categories->find('all' , $options)->first();
    
    if (empty($category)) {
        throw new NotFoundException(__('Danh mục này không tồn tại!'));
    }

    $this->set('category', $category);
    $this->set('_serialize', ['category']);
}
?>

Tiếp theo ta thực hiện chỉnh sửa router của ứng dụng 
/config/ratouers.php
<?php 
/**
 * Create by vienbk91 
 * Tạo router mới cho chickenrainshop
 */
Router::connect('/' , array('controller' => 'Books' , 'action' => 'index'));

Router::connect('/sach-moi' , array('controller' => 'Books' , 'action' => 'latest_books'));
Router::connect('/sach-moi/:book_title', array('controller' => 'Books' , 'action' => 'view') , array('pass' => array('book_title')));

Router::connect('/tac-gia'  , array('controller' => 'Writers' , 'action' => 'index'));
Router::connect('/tac-gia/:writer_title'  , array('controller' => 'Writers' , 'action' => 'view') , array('pass' => array('writer_title')));

Router::connect('/danh-muc'  , array('controller' => 'Categories' , 'action' => 'index'));
Router::connect('/danh-muc/:category_title'  , array('controller' => 'Categories' , 'action' => 'view') , array('pass' => array('category_title')));

?>

Ta cũng làm tương tự như vậy với writers


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
11. Phân trang dữ liệu quan hệ

Sau khi đã tạo link thân thiện với các phần như 
+ books => sach-moi
+ categories => danh-muc
+ writers => tac-gia

Bây giờ ta hãy xem trong phần view của category thì mỗi category lại tồn tại rất nhiều sách có quan hệ với nó, nên bây giờ thay vì hiển thị 1 danh sách dài các books đó thì ta cũng sẽ thực hiện phân trang cho nó

vd: http://localhost/chickenrainshop/danh-muc/kinh-te -> Tất cả các sách thuộc danh mục "kinh tế" sẽ được liệt kê tại đây, nên bây giờ ta sẽ đi phân trang cho nó.

Phân trang dữ liệu sách trong Categories
/src/Controller/CategoriesController.php 
<?php 
public function view($slug = null) {
    
    // B1: Lấy thông tin category tương ứng với tham số slug nhận được từ url    
    $options = array(
            'conditions' => array('Categories.slug' => $slug) ,
            'contain' => array('Books')
    );

    $category = $this->Categories->find('all' , $options)->first();

    if (empty($category)) {
        throw new NotFoundException(__('Danh mục này không tồn tại!'));
    }

    $this->set('category', $category);
    $this->set('_serialize', ['category']);

    // Kết thúc B1

    // B2: Lấy thông tin sách thuộc category này và thực hiện phân trang 
    // Do 2 bảng categories và books có quan hệ 1-n và liên kết trực tiếp nên ta có thể thông qua contain để join 2 bảng với nhau
    // Do đều sử dụng dữ liệu để phân trang cho nên ta có thể sử dụng hàm phân trang của book trong books controller
    // Ta sẽ copy phần code phân trang của bookscontroller ra và sửa đổi.
    $this->paginate = array(
            'fields' => ['id' , 'title' , 'slug' , 'sale_price' , 'image'] ,
            'order' => ['created' => 'desc'] ,
            'limit' => 5 , 
            'contain' => [ 
                        'Categories'  => function($q) {
                                return $q->select(['slug']);
                        } ,
                        'Writers' => function($q) {
                                return $q->select(['name' , 'slug']);
                        } 
                    ] ,
            'conditions' => [
                'published' => 1 ,
                'Categories.slug' => $slug
                ]
    );
    
    // Nếu chỉ khai báo $this->paginate() thì nó mặc định lấy model của controller hiện tại đang xử lý
    // Nên cần khai báo model cụ thể nếu muốn sử dụng
    // Ở đây ta dùng bảng books để tìm kiếm data nên ta cần gọi đến Books model
    $books = $this->paginate('Books');
    $this->set(compact('books'));

}
?>

/src/Template/Categories/view.ctp 
<div class="categories view large-9 medium-8 columns content">
    <h3><?= h($category->name) ?></h3>
    <table class="vertical-table">
        <tr>
            <th scope="row"><?= __('Tên thư mục') ?></th>
            <td><?= h($category->name) ?></td>
        </tr>
    </table>
    <div class="row">
        <h4><?= __('Tóm lược') ?></h4>
        <?= $this->Text->autoParagraph(h($category->description)); ?>
    </div>
    
    <!-- Thực thi phân trang dữ liệu sách cùng Categories START-->
    
    <div class="related">
        <h4><?= __('Sách cùng thư mục') ?></h4>
        <?php if (!empty($books)): ?>
            <?php echo $this->element('books' , array('books' => $books)); ?>
            <?php echo $this->element('paginator' , array('object' => 'quyển sách')); ?>
        <?php endif; ?>
    </div>
    
    <!-- Thực thi phân trang dữ liệu sách cùng Categories END -->
    
</div>



Phân trang dữ liệu sách trong Writers
Phần phân trang dữ liệu quan hệ này sẽ có 1 chút thay đổi vì trong phần này, ta sẽ phải phân trang dữ liệu books tương ứng với writers. Tuy nhiên 2 bảng này lại không có quan hệ trực tiếp với nhau
mà thông qua 1 bảng trung gian books_writers.
Theo hướng dẫn thì ta có thể sử dụng joins rồi tìm kiếm books theo conditions là Writers.slug = $slug (giá trị tham số nhận vào từ view)

/src/Controller/WritersController.php
<?php 
public function view($slug = null) {

    // Lấy toàn bộ thông tin của tác giả có slug tương ứng với param được truyền vào từ view
    $writer = $this->Writers->find('all')
                        ->where(['Writers.slug' => $slug])
                        ->contain(['Books'])
                        ->autoFields(false)
                        ->first();

    $this->set('writer', $writer);
    // Đến đây là kết thúc phần lấy thông tin tác giả và hiển thị nó ra view theo mong muốn 
    // Tiếp theo ta sẽ phải đi thực hiện việc phân trang dữ liệu sách do tác giả này viết ra thông qua slug của tác giả
    // Không hiểu sao làm theo hướng dẫn nhưng không thực hiện được việc join 3 bảng với nhau và Writers.slug luôn được thông báo là không được xác định
    
    // Lấy ra tất cả các cuốn sách có slug tác giả là $slug
    /**
     * 
     * Link tham khảo: http://stackoverflow.com/questions/29737422/conditions-to-paginate-for-belongstomany-cakephp-3 
     */
    $booksInstance = TableRegistry::get('books');
    $books = $booksInstance->find()
                        ->matching('Writers', function(\Cake\ORM\Query $q) use ( $slug ) {
                                return $q->where([
                                        'Writers.slug' => $slug
                                ]);
                            }
                        );
    
    // Thêm điều kiện phân trang thông qua 1 biến toàn cục $paginate
    $this->paginate = [
            'fields' => ['id' , 'title' , 'slug' , 'sale_price' , 'image'] ,
            'order' =>  ['created' => 'desc'] , // Từ mới nhất đến cũ dần
            'limit'=>2
    ];
    $this->set('books' , $this->paginate($books));
    
}
?>

/src/Template/Writers/view.ctp 
<div class="writers view large-9 medium-8 columns content">
    <h3><?= h($writer->name) ?></h3>
    <table class="vertical-table">
        <tr>
            <th scope="row"><?= __('Tên tác giả') ?></th>
            <td><?= h($writer->name) ?></td>
        </tr>
    </table>
    <div class="row">
        <h4><?= __('Tiểu sử') ?></h4>
        <?= $this->Text->autoParagraph(h($writer->biography)); ?>
    </div>
    <div class="related">
        <h4><?= __('Sách đã xuất bản') ?></h4>
            <?php 
                foreach ($books as $book) {
                    echo $this->Html->link($book->title , '/sach-moi/' . $book->slug , array('target' => '_self')) . "<br>";
                    echo $this->Html->image($book->image , array(
                            'width' => '120px' ,
                            'height' => '160px'
                    )) . "<br><br>";
                    echo "Giá bán: " . $this->Number->format($book->sale_price , array(
                            'places' => 0 ,
                            'after' => 'VND'
                    )) . "<br>";
                    echo "Tác giả: ";
                    //foreach ($book->_machingData['Writers'] as $writer) { 
                        echo $book->_matchingData['Writers']['name'] . "   ";
                    //}
                    echo "<hr>";
                }
            ?>
            <?php echo $this->element('paginator' , array('object' => 'quyển sách')); ?>
    </div>
</div>



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
10. Hiển thị thông tin chi tiết của sách trên chickenrainshop

Thay đổi nội dung trang thông tin chi tiết của sách, bằng cách bỏ đi 1 số nội dung hiển thị không cần thiết, 
thay đổi nội dung phần comments và phần thông tin tác giả


/src/Controller/BooksController.php

<?php 
public function view($slug = null) {

    	// Lấy thông tin của sách theo $slug nhận từ url
    	$book = $this->Books->find('all')
							->where(['Books.slug' => $slug])
    						->contain([
    								'Categories', 
    								'Writers',
    								'Comments'
    						])
    						->first();
    	
        if (empty($book)) {
            throw new NotFoundException(__('Không tìm thấy cuốn sách này'));
        }
        
        // Đưa thông tin sách đã được xử lý ra view
        $this->set('book', $book);
}
?>

Thay đổi nội dung view
/src/Template/Books/view.ctp
<div class="books view large-9 medium-8 columns content">
    <h3><?= h($book->title) ?></h3>
    <table class="vertical-table">
        <tr>
            <th scope="row"><?= __('Thư mục') ?></th>
            <td><?= $book->has('category') ? $this->Html->link($book->category->name, ['controller' => 'Categories', 'action' => 'view', $book->category->slug]) : '' ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Tiêu đề') ?></th>
            <td><?= h($book->title) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Ảnh bìa') ?></th>
            <td><?php echo $this->Html->image($book->image , array('width' => '120px' ,'height' => '160px')); ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Link Download') ?></th>
            <td><?= $this->Html->link('Link download' , $book->link_download , ['target' => '_blank']) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Giá gốc') ?></th>
            <td><?= $this->Number->format($book->price , array('places' => 0 ,'after' => 'VND')) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Giá sale') ?></th>
            <td><?= $this->Number->format($book->sale_price , array('places' => 0 ,'after' => 'VND')) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Số trang') ?></th>
            <td><?= $this->Number->format($book->pages) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Tác giả') ?></th>
            <td>
            <?php 
            $countWriter = 0;
            foreach ($book->writers as $writer) {
                $url = $this->Html->link($writer->name , '/tac-gia/' . $writer->slug , ['target' => '_self']);
                if ($countWriter < count($book->writers) -1 ) {
                    echo $url . "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
                } else {
                    echo $url;
                }
                
                $countWriter++;
            }
            ?>
            </td>
        </tr>
    </table>
    <div class="row">
        <h4><?= __('Thông tin sách') ?></h4>
        <?= $this->Text->autoParagraph(h($book->info)); ?>
    </div>
</div>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
11. Thay đổi thông tin comment trong phần hiển thị thông tin sách và thông tin tác giả
Ở đây mục đích của mình là lược bỏ các thông tin không cần thiết trong hiển thị comment và thay vì hiển thị user_id, ta sẽ đi hiển thị thông tin tên người dùng.
Thông tin tên người dùng được lưu trữ trong bảng Users , và có khóa ngoài user_id liên kết với bảng Comments. Như vậy ta sẽ bổ sung thêm thông tin Users trong câu lệnh query như sau: 

/src/Controller/BooksController.php

<?php 
public function view($slug = null) {
	// Lấy thông tin của sách theo $slug nhận từ url
	$book = $this->Books->find('all')
						->where(['Books.slug' => $slug])
						->contain([
								'Categories', 
								'Writers', 
								// Lấy thêm dữ liệu từ bảng Users - là bảng có quan hệ với bảng Comments
								'Comments' => function(\Cake\ORM\Query $q) {
									return $q->contain(['Users'])->select();
								}
						])
						->first();

	if (empty($book)) {
		throw new NotFoundException(__('Không tìm thấy cuốn sách này'));
	}

	// Đưa thông tin sách đã được xử lý ra view
	$this->set('book', $book);
}
?>

Thay đổi nội dung view 
/src/Template/Books/view.ctp
<div class="books view large-9 medium-8 columns content">
    <h3><?= h($book->title) ?></h3>
    <table class="vertical-table">
        <tr>
            <th scope="row"><?= __('Thư mục') ?></th>
            <td><?= $book->has('category') ? $this->Html->link($book->category->name, ['controller' => 'Categories', 'action' => 'view', $book->category->slug]) : '' ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Tiêu đề') ?></th>
            <td><?= h($book->title) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Ảnh bìa') ?></th>
            <td><?php echo $this->Html->image($book->image , array('width' => '120px' ,'height' => '160px')); ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Link Download') ?></th>
            <td><?= $this->Html->link('Link download' , $book->link_download , ['target' => '_blank']) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Giá gốc') ?></th>
            <td><?= $this->Number->format($book->price , array('places' => 0 ,'after' => 'VND')) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Giá sale') ?></th>
            <td><?= $this->Number->format($book->sale_price , array('places' => 0 ,'after' => 'VND')) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Số trang') ?></th>
            <td><?= $this->Number->format($book->pages) ?></td>
        </tr>
        <tr>
            <th scope="row"><?= __('Tác giả') ?></th>
            <td>
            <?php 
			// Xử lý việc hiển thị nhiều tác giả (một cuốn sách có thể do nhiều tác giả viết) nên ta sẽ xử lý hiển thị cho đẹp và tạo đường dẫn đến trang thông tin tác giả
            $countWriter = 0;
            foreach ($book->writers as $writer) {
                $url = $this->Html->link($writer->name , '/tac-gia/' . $writer->slug , ['target' => '_self']);
                if ($countWriter < count($book->writers) -1 ) {
                    echo $url . "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
                } else {
                    echo $url;
                }
                
                $countWriter++;
            }
            ?>
            </td>
        </tr>
    </table>
    <div class="row">
        <h4><?= __('Thông tin sách') ?></h4>
        <?= $this->Text->autoParagraph(h($book->info)); ?>
    </div>
    
    <!-- Thay đổi nội dung hiển thị comment: Chỉ hiển thị comment và thay user_id thành tên người comment -->
    <div class="related">
        <h4><?= __('Bình luận') ?></h4>
        <?php if (!empty($book->comments)): ?>
        <table cellpadding="0" cellspacing="0">
            <tr>
                <th scope="col"><?= __('Người bình luận') ?></th>
                <th scope="col"><?= __('Nội dung bình luận') ?></th>
                <th scope="col"><?= __('Ngày đăng') ?></th>
                <th scope="col" class="actions"><?= __('Actions') ?></th>
            </tr>
            <?php foreach ($book->comments as $comments): ?>
            <tr>
                <td><?php echo $comments['user']['username']; ?></td>
                <td><?php echo $comments->content; ?></td>
				<!-- Hiển thị thời gian theo giờ GMT của khu vực Asia/Tokyo -->
                <td>
				<?php 
				date_default_timezone_set('Asia/Tokyo');
				echo date('Y-m-d H:i:s' , strtotime($comments->created . 'GMT')); 
				?>
				</td>
                <td class="actions">
                    <?= $this->Html->link(__('View'), ['controller' => 'Comments', 'action' => 'view', $comments->id]) ?>
                    <?= $this->Html->link(__('Edit'), ['controller' => 'Comments', 'action' => 'edit', $comments->id]) ?>
                    <?= $this->Form->postLink(__('Delete'), ['controller' => 'Comments', 'action' => 'delete', $comments->id], ['confirm' => __('Are you sure you want to delete # {0}?', $comments->id)]) ?>
                </td>
            </tr>
            <?php endforeach; ?>
        </table>
        <?php endif; ?>
    </div>
    
    <!-- Rút gọn thông tin tác giả và thêm vào đường dẫn tới trang view thông tin tác giả -->
    <div class="related">
        <h4><?= __('Thông tin tác giả') ?></h4>
        <?php if (!empty($book->writers)): ?>
        <table cellpadding="0" cellspacing="0">
            <tr>
                <th scope="col" width="15%"><?= __('Name') ?></th>
                <th scope="col" width="60%"><?= __('Biography') ?></th>
                <th scope="col" width="25%" class="actions"><?= __('Actions') ?></th>
            </tr>
            <?php foreach ($book->writers as $writers): ?>
            <tr>
                <td><?= h($writers->name) ?></td>
                <td><?= h($writers->biography) ?></td>
                <td class="actions" align="center">
                    <?= $this->Html->link(__('View'), ['controller' => 'Writers', 'action' => 'view', $writers->slug]) ?>
                    <?= $this->Html->link(__('Edit'), ['controller' => 'Writers', 'action' => 'edit', $writers->id]) ?>
                    <?= $this->Form->postLink(__('Delete'), ['controller' => 'Writers', 'action' => 'delete', $writers->id], ['confirm' => __('Are you sure you want to delete # {0}?', $writers->id)]) ?>
                </td>
            </tr>
            <?php endforeach; ?>
        </table>
        <?php endif; ?>
    </div>
</div>


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
12. Bổ sung phần hiển thị sách cùng thư mục trong trang thông tin sách 

Để hiển thị sách cùng thư mục thì trong action view ta cần sử lý việc lấy ra thông tin của sách cùng category
/src/Controller/BooksController.php
<?php 
/**
 * View method
 * Hiển thị nội dung của từng quyển sách kèm theo comment và thông tin tác giả
 * @param string|null $slug Book slug.
 * @return \Cake\Network\Response|null
 * @throws \Cake\Datasource\Exception\RecordNotFoundException When record not found.
 */
public function view($slug = null) {
	
	/* 中断　- Phần mã được viết trong mục 11 */
	/* Bổ sung phần code dưới đây vào để hiển thị các cuốn sách trong cùng thư mục */
	// Lấy thông tin sách liên quan
	$bookInstance = TableRegistry::get('Books');
	$related_book = $bookInstance->find('all')
						->select(['title' , 'image' , 'slug' , 'sale_price'])
						->where([
								'Books.category_id' => $book->category_id ,
								'Books.id <>' => $book->id ,
								'Books.published' => 1
						])
						->order(['created' => 'desc'])
						->contain([
								'Writers' => function(\Cake\ORM\Query $q) {
									return $q->select(['name' , 'slug']);
								}
						]);
	
	 
	// Hiển thị toàn bộ sách trong cùng categories
	// $this->set('related_book' , $related_book);
	
	// Phân trang sách trong cùng catogories
	$this->paginate = [
			'fields' => ['id' , 'title' , 'slug' , 'sale_price' , 'image'] ,
			'order' =>  ['created' => 'desc'] , // Từ mới nhất đến cũ dần
			'limit'=>2
	];
	$this->set('related_book' , $this->paginate($related_book));
}
?>

Bổ sung vào file /Template/Books/view.ctp 
Thêm thẻ <div> vào ngay phía dưới phần hiển thị thông tin tác giả 

<div class="related">
	<h4><?= __('Sách trong cùng thư mục') ?></h4>
	<div class="books index large-9 medium-8 columns content">
		<?php echo $this->element('books' , array('books' => $related_book)); ?>
		<?php echo $this->element('paginator' , array('object' => 'quyển sách')); ?>
	</div>
</div>


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
13. Tạo chức năng gửi comment cho trang hiển thị thông tin sách 
Trong video hướng dẫn thì tác giả sử dụng FormHelper có sẵn của CakePHP để tạo các form. Tuy nhiên cách viết smaty enginee này khá khó chịu và mình cũng không thích lắm.
Cho nên mình sẽ thay lại toàn bộ code phần gửi form comment thành mã HTML thuần như sau: 
Phần mã này sẽ được thêm vào bên dưới phần hiển thị nội dung comment và trên phần hiển thị thông tin tác giả 

/Template/Books/view.ctp 
<!-- Thêm comments -->
<div class="related">
	<h4><?= __('Thêm bình luận') ?></h4>
	<!-- 
	Thông thường thì trong action của form sẽ được gọi đến action tương ứng trong controller , nhưng ở đây do ta đã thay đổi url thành các link thân thiện cho nên khi gọi đến các action trong controller 
	thì url cũng sẽ hiển thị theo controller/action tương ứng mà ta gọi đến.
	Vì thể ta sẽ sử dụng url được Router định nghĩa và nó vẫn sẽ gọi đến ['controller' => 'books' , 'action' => 'view'] , ['param' => $book->slug]
	-->
	<form action="<?php echo Cake\Routing\Router::url('/sach-moi/' . $book->slug); ?>". <?= $book->slug ?> method="post" name="comment" id="comment" accept-charset="utf-8" >
	<fieldset>
		<label>Nội dung bình luận</label>
		<textarea rows="8" cols="5" name="content" id="content" style="width: 100% !important;"><?php  ?></textarea>
	</fieldset>
	<input type="hidden" name="user_id" id="user_id" value="1" />
	<input type="hidden" name="book_id" id="book_id" value="<?php echo $book->id; ?>" />
	<input type="hidden" name="slug" id="slug" value="<?php echo $book->slug; ?>" />
	<input type="submit" name="submit" id="submit" value="Đăng bình luận" 
	style="background: #966600;float: left;text-transform: uppercase;box-shadow: none;border-width: 0; height: 40px;border: 0px;width: 140px;" onclick="checkContent()">
	</form>
</div>
<!-- Kết thúc thêm comments -->

/src/Controller/BooksController.php
Trong controller ta sẽ xử lý form như sau :
Bổ sung đoạn mã sau vào phần action view của BooksController
<?php 
public function view($slug = null) {
	
	if ($this->request->is('post')) { // Kiểm tra có request post gửi lên từ view hay không 
		$commentInstance = TableRegistry::get('Comments'); // Tạo 1 thể hiện của Comment Table Object
		$comment = $commentInstance->newEntity($this->request->data); // Tạo ra 1 emtity xử lý việc thêm, sửa, xóa dữ liệu , ở đây dữ liệu đầu vào chính là dữ liệu được lấy thông qua $this->request->data
		if ($commentInstance->save($comment)) { // Thực hiện lưu dữ liệu
			$this->Flash->success(__('Thêm bình luận thành công.'));
		} else {
			$this->Flash->error(__('Thêm bình luận thất bại.'));
		}
	}
	
	// Phía dưới là phần mã đã đc viết trong phần 11,12 
}

?>

Ở đây ta chú ý trong view ta có thực hiên 1 hàm onclick để check việc content trống thì sẽ không được submit gửi bình luận 
Do ta có sử dụng thêm jquery nên trước hết ta cần khai báo thêm thư viện jquery trong Template/Layout/default như sau: 
Thêm file thư viện jquery 
/webroot/js/jquery-3.1.0.min.js

/Template/Layout/default
<?php echo $this->Html->script('jquery-3.1.0.min'); ?>

Và ta sẽ đặt hàm xử lý javascript trên đầu file view như sau
<script type="text/javascript">
function checkContent() {
	if ($.trim($('#content').val())==="") {
		$("#comment").submit(function(){
			return false;
		});
		alert('Nội dung ghi chú không được để trống ! Hãy nhập vào !');
		//document.addForm.content.focus();
		$("#content").focus();
		return false;
	} else {
		return true;
	}
}
</script>

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
14. Counter cache - Ứng dụng đếm số comments của từng quyển sách

Tạm thời bỏ qua phần này 

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
15. Tạo chức năng tìm kiếm sách trên ChickenRainShop




