//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CakePHP3.3.1 Kiến thức cơ bản và cách xây dựng chickenrainshop project
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Phần 1: Các thiết lập ban đầu

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
1. Phân tích yêu cầu: 
Chickenrainshop là dự án triển khai hệ thống bán sách online được xây dựng bằng CakePHP3.3
Nó bao gồm 3 phần chính: 
 + Home: Trang chủ, hiển thị danh sách các cuốn sách có trong kho (bổ sung chức 
năng tìm kiếm sách,...)
 + Thông tin sách: hiển thị nội dung cụ thể từng cuốn sách
 + Thông tin giỏ hàng: Hiển thị thông tin giỏ hàng của khách khi đặt mua sách 
Ngoài ra chức năng admin sẽ được sử dụng để quản lý sách.



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2. Xây dựng mô hình dữ liệu và csdl cho project 

CDM: Conceptual Data Model (Mô hình dữ liệu quan niệm hay mô hình quan niệm thực thể): 
là mô hình chi tiết mô tả toàn bộ cấu trúc dữ liệu tổ chức mà nó không phụ thuộc vào 
bất kỳ một hệ quản trị cơ sở dữ liệu nào hay sự xem xét việc cài đặt. Đây là một mô 
hình biểu diễn mức độ hợp lý, chi tiết về dữ liệu của một tổ chức hay một hệ thống.
CDM biểu diễn các thực thể chứa các thuộc tính và các thực thể này có quan hệ với nhau, 
có thể là 1-nhiều, nhiều-nhiều, hay là nhiều-1.

PDM: Physical Data Model (Mô hình dữ liệu vật lý) mô hình này thể hiện sự sắp xếp và cài 
đặt của dữ liệu trên một hệ quản trị cơ sở dữ liệu nào đó (trong video thì PDM thể hiện 
sự cài đặt của dữ liệu trên mySQL).
PDM biểu diễn các table (bảng) có mối quan hệ với nhau, mỗi bảng có nhiều trường dữ liệu 
trong đó.

Các quy tắc của CakePHP khi tạo CSDL:

- Tên bảng đặt theo dạng số nhiều của tiếng anh (thêm s, hoặc es)
VD: teams, books, matches...
Và không dùng các từ dễ bị nhầm lẫn với từ khóa của CakePHP(file, new...)
- Khóa chính (primary key) được quy định tên mặc định là id, thuộc kiểu int và là trường 
số tự tăng (auto_increment)
- Khóa ngoại (foreign key) được quy định là tên bảng ở dạng số ít và kèm với cụm _id.
VD: category_id, book_id...

- Các trường created và modified: thuộc kiểu dateime hoặc timestamp mặc định là null. 
Và 2 trường này dùng để lưu ngày tạo mẩu tin (created), và ngày bạn update mẩu tin đó 
(updated) một cách tự động, và chúng ta không cần phải thao tác gì trên đó cả.


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
3. Xây dựng Model - View - Controller từ csdl đã có

1.1. Cài đặt componer với Xampp
Bây giờ ta sẽ vào trang chủ của Composer-> Getting Started -> Locally -> Click vào link: the Dowload Page và nó sẽ đưa ta đến đường dẫn sau:
https://getcomposer.org/download/ 
Tại đây bạn sẽ thấy có 2 cách cài đặt và sử dụng file exe để cài trực tiếp hoặc dùng commandline để cài bằng dòng lệnh. Tôi sử dụng commandline
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
php composer-setup.php
php -r "unlink('composer-setup.php');"
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Bây giờ ta chỉ việc bật chế độ Shell của Xampp, di chuyển tới thư mục htdocs 
(chương trình Shell mặc định root tại thư mục cài đặt xampp nên ta cần di chuyển tới thư mục htdocs ở bên trong nó )
>cd htdocs
Parse đoạn mã trên vào, nó sẽ thực thi từng dòng lệnh 1 như sau

> php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
> php -r "if (hash_file('SHA384', 'composer-setup.php') === 'e115a8dc7871f15d853148a7fbac7da27d6c0030b848d9b3dc09e2a0388afed865e6a3d6b3c0fad45c48e2b5fc1196ae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
> php composer-setup.php
> php -r "unlink('composer-setup.php');"

Và đây là kết quả thực thi
 
Bây giờ bên trong thư mục htdocs sẽ xuất hiện 1 file đó là Conposer.phar , đây chính là file thực thi của conposer
 
1.2. Tạo project chickenrainshop
Tiếp theo ta sẽ sử dụng composer để tạo 1 project tên là bookmarker. Vẫn tiếp tục bằng chương trình Shell Command của Xampp, ta thực thi lệnh sau:

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
php composer.phar create-project --prefer-dist cakephp/app chickenrainshop
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Sau khi đợi nó tự động install các package cần thiết thì nó sẽ hỏi bạn có muốn thiết lập quyền sở hữu (folder permissions) cho folder “app/config” hay không? Bạn hãy chọn y
Như vậy bây giờ trong thư mục htdocs đã tự động sinh ra 1 project có tên là “chickenrainshop” 

Ta import csdl đã được xây dựng vào database có tên: chickenrainshop

Bởi vì database được thiết kế theo những quy ước của CakePHP, 
cho nên ta có thể sử dụng chương trình “bake console” để sinh ra một cách nhanh chóng 
một chương trình đơn giản. Ta thực thi các lệnh sau:

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# cd htdocs/bookmarker
# bin\cake bake all books
# bin\cake bake all categories
# bin\cake bake all comments
# bin\cake bake all coupons
# bin\cake bake all groups
# bin\cake bake all orders
# bin\cake bake all users
# bin\cake bake all writers
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Sau khi thực thi tất cả các lệnh trên thì nó đã tự động sinh code ra cho chúng ta.
Ngoài ra trong phần này mình cũng nhắc qua về 1 số quy ước khi viết front-end và back-end
Ở đây mình định nghĩa 
front-end là phần xử lý view của người dùng, là phần hệ thống tương tác trực tiếp với người 
dùng như là hiển thị danh sách sách , search sách , hiển thị thông tin sách , hiển thị giỏ hàng, 
thao tác giỏ hàng và các xử lý tương tác
back-end là phần của admin dùng để xử lý việc thêm , sửa, xóa ,...đối với sách cũng như người dùng.
Như vậy để dễ dàng hơn khi làm việc, ta sẽ tuân thủ 1 số quy định sau đây: 
+ URL:
front-end: /controller/action -> URL: /books/index
back-end:  /admin/controller/action -> URL: admin/books/admin_index
+ Action - View
front-end: function index(){} -> view tương ứng: index.ctp
back-end:  function admin_index() {} => view tương ứng: admin_index.ctp
+ Layout
Trong cake thì khi sử dụng layout nó được mặc định sử dụng 1 layout là default.ctp
Như vậy ta cũng sẽ phân chia layout mặc định của front-end và back-end như sau:
front-end layout: Layout/default.ctp
back-end layout:  Layout/admin.ctp

Bây giờ ta sẽ tìm hiểu qua về file default.ctp và cấu trúc của nó.
File này là file layout mặc định được cake sử dụng khi load trang , nó là nơi định nghĩa các 
file css , js được sử dụng trong chương trình (Khi phát triển thì có thể tùy mục đích mà ta định nghĩa
lại cũng được)

Trong cakePHP2.x thì nó được viết 
<?php
    echo $this->Html->meta('icon');

    echo $this->Html->css('cake.generic');
    echo $this->Html->css('mystyle');
    
    echo $this->Html->script('jquery-3.1.0.min');

    echo $this->fetch('meta');
    echo $this->fetch('css');
    echo $this->fetch('script');
?>

Ở đây nó sử dụng Helper Html do cake xây dựng sẵn để load file css,js theo tên của chúng.
Các file này sẽ được đặt trong thư mục webroot/css và webroot/js

Tuy nhiên chuyển sang CakePHP3.x thì nó có cách viết khá lạ
<?= $this->Html->css('mystyle') ?>
Vậy cách này thì có gì khác cách trên ? Thực ra là không khác gì nhau cả, cách viết này
là một dạng short_open_tag (bạn có thể đọc về echo trong php để tìm hiểu về cách viết này)

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Phần 2: Quản lý nội dung
4. Các phương pháp truy vấn dữ liệu trong CakePHP

Trong CakePHP , thông thường sử dụng 2 hàm là find() và query() để truy vấn dữ liệu
Ta sẽ đi nói về từng hàm, chức năng và cách dùng của nó
1 - find($type , $option)
Đối với $type - kiểu truy vấn:
+all : tìm và lấy hết các mẫu tin trong csdl
+fist: tìm và trả về mẫu tin đầu tiên tìm thấy trong csdl
+list: tương tự như all nhưng chỉ trả về id
+count:tìm những dữ liệu đc yêu cầu và trả về số mẫu tin mà nó tìm được
+neighbors: Trả về mẫu tin đứng trước và sau mẫu tin mà chúng ta yêu cầu nó tìm
+threaded: Giống như là all, nhưng chỉ sử dụng cho dữ liệu có cấu trúc cây. 
chẳng hạn như khi ta sử dụng TreeBehavior vào tìm categories thì ta cần dùng sử 
dụng kiểu truy vấn này để làm cây danh mục.

Đối với option - các tùy chọn khi truy vấn và được đặt trong 1 mảng (với tùy chọn là key , 
và điều kiện ràng buộc cho tùy chọn là value) , có 1 số tùy chọn mà ta hay sử dụng khi truy vấn: 

+fields: Tùy chọn này sẽ giúp chúng ta lấy các trường dữ liệu mà chúng ta muốn trong csdl
Nếu chỉ muốn lấy 1 trường thì ta đặt nó trong 1 cặp dấu nháy('') , nhưng nếu lấy nhiều trường
thì ta cần đặt nó trong mảng
+conditions: Điều kiện khi tìm kiếm csdl
Tương tự như câu lệnh where trong query, và các điều kiện cũng được đặt trong 1 mảng
+order: sắp xếp csdl theo 1 trường nào đó theo 1 thứ tự nào đó
+limit: Lấy ra số lượng mẫu tin chỉ định (chỉ định là interger)
+recursive: Tùy chọn này sẽ lấy dữ liệu theo mối quan hệ của bảng dữ liệu mà ta cần lấy
Và có 4 mức recursive cho chúng ta tùy chọn là : -1 , 0 , 1 và 2

VD: //Cakephp2.x
$notes = $this->Note->find('all' , array(
    'fields' => array('id' , 'title' , 'content') ,
    'conditions' => array('title LIKE' => '%PHP%') ,
    'order' => array('id' => 'asc') , // array('id asc'); cũng được
    'limit' => 5
));

$notes = $this->Note->find('first');

Trong cakephp2.x thì việc sử dụng find($type , $option) sẽ không có vấn đề gì xảy ra nhưng
từ cakephp3.x trở đi, nó đã được thay thế khá nhiều.

Ở cakephp2.x thì kết quả của find sẽ trả về mảng, tuy nhiên từ 3.x trở đi thì tất cả đều được
đưa về dưới dạng object. Vì thế việc sử dụng hàm pr($var) khá là khó debug trong cakephp3.x

Trong cakephp3.x document, hàm find() cũng được support nhưng đã có nhiều thay đổi trong cách sử dụng.
Do từ 3.x trở đi, cake không sử dụng trực tiếp 1 class Model mà thông qua 2 class Table và Modify nên
khi sử dụng ta cần tạo ra 1 instance của Table.
Vì thế trước khi sử dụng hàm find() này, ta cần load instance của Table bằng cách:

$instance_tbl = TableRegistry::get('table_name');
$result = $instance_tbl->find('all' , $option)->type_name();

Trong cakephp3.x thì những $type = 'first' , 'count' sẽ không còn sử dụng được nữa , mà thay vào đó
ta sẽ chỉ sử dụng $type = 'all' với $option , sau đó lấy kết quả thu được gọi tới first() , count()
VD:
$noteInstance = TableRegistry::get('Notes');
$notes = $noteInstance->find('all');
$first = $notes->first(); // $note->find()->first();
$count = $notes->count(); // $note->find()->count();

Về find list thì ta vẫn có thể sử dụng nó như 1 $type đặt trong find() được
$bookInstance->find('list' , $option);
Tuy nhiên list này sẽ ko phải trả về id mà sẽ trả về danh sách của $this->displayField('');
đã được định nghĩa trong Table. Nếu trong class Table không ghi gì thì nó sẽ mặc định là id.

Trong cakephp3.x thì recursive đã được loại bỏ mà thay vào đó chúng ta sẽ sử dụng contain để quản lý việc đó.

Đối với find('neghbors') thì trong CakePHP3.x đã không còn hỗ trợ nó nữa, nên nếu muốn sử dụng bạn có thể
biến tấu nó theo cách sau:
src/Models/Table/ExampleTable.php
/**
 * Find an item from a table by slug, along with it's two adjacent items
 *
 * @param string $slug
 * @return array
 */
public function neighbours(Query $query , $slug) {
    $current = $this->find()
        ->where(['slug' => $slug])
        ->first();

    $previous = $this->find()
        ->where(['publish_date <' => $current->publish_date->format('Y-m-d')])
        ->order(['publish_date' => 'DESC'])
        ->first();

    $next = $this->find()
        ->where(['publish_date >' => $current->publish_date->format('Y-m-d')])
        ->order(['publish_date' => 'DESC'])
        ->first();

    return [
        'current' => $current,
        'previous' => $previous,
        'next' => $next
    ];
}
src/Controller/ExamplesController.php
public function view($id = null) {
    $neighbors = $this->Examples->find('neighbors', $id );
}

Ngoài ra thì ta có thể sử dụng thêm 1 số cách truy vấn khác cũng với find() như sau:
$instance->find()
    ->where(条件A)
    ->where(条件B)
    ->order(ソート条件A)
    ->order(ソート条件B)
    ->select(取得フィールド)
    ->all();
Cụ thể hơn ta có thể tham khảo tại: 
Cake3.x find():
+ http://qiita.com/kozo/items/87dc9f725e71dd742468 
+ http://qiita.com/zayarwinttun/items/7afae4cc9f5388babc38
Cake2.x find(): http://qiita.com/Tomooki_Tatsuguchi/items/7ea21324dd90d9cf92d7

Trong bài viết này, tác giả đã ghi rõ những thay đổi trong việc khai báo find() cũng như 
sử dụng các type , option của nó trong cakephp2.x và 3.x
http://norm-nois.com/blog/archives/3319 


2- query() 
Đối với query() thì sẽ rất thuận tiện cho những ai chưa thực sự quen thuộc với hàm find()
Vì chỉ cần viết câu lệnh SQL và truyền vào query như 1 tham số thì nó sẽ thực thi tìm kiếm
như những gì câu lệnh sql yêu cầu.
$sql = "select * from books";
$result = $this->Model->query($sql);

Tuy nhiên trong CakePHP3.x thì cách này đã không còn được sử dụng trực tiếp thông qua Model
mà thay vào đó ta phải dùng như sau:

use Cake\Datasource\ConnectionManager;

$sql = 'SELECT * FROM articles';
$connection = ConnectionManager::get('my_connection')->execute($sql);
// Get one row
$results = $connection->fetch('assoc');
// Get all row
$results = $connection->fetchAll('assoc');


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
5. Quan hệ giữa các Model trong CakePHP
Các mối quan hệ trong CakePHP
Quan hệ 1-1: 1 thể hiện của A chỉ có thể có 1 thể hiện của B và ngược lại, 1 thể hiện của B
chỉ thuộc 1 thể hiện của A.
              A           <---(      chỉ có 1        )---->      B
           (hasOne)                                           (hasOne)
Quan hệ 1-n: 1 thể hiện của A có thể có 1 hoặc nhiều thể hiện của B , 1 thể hiện của B chỉ
thuộc về 1 thể hiện của A
              A           ----(có thể có 1 hoặc nhiều)---->      B
           (hasMany)      <---(     chỉ thuộc về     )----   (belongTo)
Quan hệ n-n: 1 thể hiện của A có thể có 1 hoặc nhiều thể hiện của A và ngược lại.
              A           <-----(  có 1 hoặc nhiều   )---->      B
           (belongsToMany)                                   (belongsToMany)

Ta có thể xem về việc định nghĩa các mối quan hệ này trong các Table Object:
Trong BooksTable ta thấy định nghĩa:
        // 1 Book thì chỉ thuộc về 1 Categories
        $this->belongsTo('Categories', [
            'foreignKey' => 'category_id'
        ]);
        // 1 book thì có thể có 1 hoặc nhiều Comments
        $this->hasMany('Comments', [
            'foreignKey' => 'book_id'
        ]);
        // Một Book có thể có 1 hoặc nhiều người viết và 1 người có thể viết 1 hoặc nhiều sách
        // Ta cũng sẽ thấy 1 định nghĩa tương tự trong WritersTable Object
        $this->belongsToMany('Writers', [
            'foreignKey' => 'book_id',
            'targetForeignKey' => 'writer_id',
            'joinTable' => 'books_writers'
        ]);


6. Sử dụng Containable Behavior
Bài này tạm thời bỏ qua

7. Tạo lại chức năng hiển thị book mới
+ Chỉnh sửa router để trang chủ là trang hiển thị books
Đầu tiên ta vào /config/routes.php và thêm vào: 
// Với định nghĩa này thì nó sẽ mặc định root sẽ đi vào controller books tại action index.
Router::connect('/' , array('controller' => 'books' , 'action' => 'index'));

+ Viết lại Controller

+ Viết lại Template/Books/index.ctp


Vấn đề: Khi sử dụng 'contain' thì viết truy vấn 
'contain' => ['Writers' => ['fields' => 'name']]
sẽ không thể thực thi mà ta cần sử dụng callback như sau:
->contain([
        'Writers' => function($q) {
            return $q->select(['name']);
        }
])

+ Tách xử lý với Model thành 1 method riêng


7. Phân trang dữ liệu trong CakePHP

Hiện tại ta chỉ show ra 5 books mới nhất trong database, vậy nếu muốn xem tất cả sách
nhưng không phải hiển thị thành 1 danh sách toàn bộ dữ liệu như hiện tại thì ta cần sử dụng phân
trang trong CakePHP. Cake đã hỗ trợ việc phân trang này

Tạo 1 link xem dữ liệu mới:
+ Bổ sung link vào Template/Books/index.ctp
<h4><?php echo $this->Html->link('Xem thêm' , '/sachmoi/') ?></h4>
vào ngay phía dưới tiêu đề của trang index.ctp

Như vậy ta đã tạo thêm 1 phần mới dùng để hiển thị sách dưới dạng phân trang.
Trước hết ta sẽ khai báo router cho nó như sau:
+ Bổ sung router
Router::connect('/sachmoi' , array('controller' => 'books' , 'action' => 'latest_books'));
+ Thêm action trong BooksController
Do trong trang latest_books ta sẽ phân trang dữ liệu nên việc sử dụng lại hàm latest() trong BooksTable
là không phù hợp. Và ta cũng sẽ không thể find() dữ liệu trực tiếp ra view được.

Ở đây ta sẽ sử dụng hàm paginate()


+ Thêm view mới Template/Books/latest_books.ctp (tên view phải tương ứng tên action)
